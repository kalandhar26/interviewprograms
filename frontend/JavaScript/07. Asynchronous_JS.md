## Timers

- Imagine your mom sets an alarm. â€œWake me up after 5 minutesâ€ Or â€œRing the bell every day at 7 AMâ€

### setTimeout

- setTimeout executes a function once after a specified delay (in milliseconds).
- You tell your friend: â€œCall me after 3 secondsâ€. The call happens only once. That is setTimeout

```javascript
setTimeout(() => {
  console.log("Hello after 2 seconds");
}, 2000);
```

- output

```text
Hello after 2 seconds
```

- Cancel set Timeout

```javascript
const timerId = setTimeout(() => {
  console.log("Won't run");
}, 3000);

clearTimeout(timerId);
```

### setInterval

- setInterval repeatedly executes a function at fixed time intervals.
- Your alarm rings: â€œEvery 1 minute, remind me to drink water ðŸ’§â€. It keeps ringing again and again.That is setInterval

```javascript
setInterval(() => {
  console.log("Tick");
}, 1000);
```

- output

```text
Tick
Tick
Tick
```

- Stop Interval

```javascript
const intervalId = setInterval(() => {
  console.log("Running...");
}, 1000);

setTimeout(() => {
  clearInterval(intervalId);
}, 5000);
```

- Runs for 5 seconds, then stops

## callbacks

- A callback is a function passed as an argument to another function, to be executed later.
- Imagine you tell your friend: â€œFinish your homework ðŸ“š, then call me ðŸ“žâ€. Your friend does work first, then calls you
  back. That â€œcall me laterâ€ function is a callback.

- Callbacks are a fundamental concept in JavaScript, especially when dealing with asynchronous operations.

```javascript
function greet(name, callback) {
  console.log("Hello " + name);
  callback();
}

function sayBye() {
  console.log("Bye!");
}

greet("Ali", sayBye);
```

- output

```text
Hello Ali
Bye!
```

- Functions are first-class citizens in JS
- Functions can be passed like variables

## Async Callback

- You order food. Cooking takes time, Instead of waiting and blocking:
- You say: â€œWhen food is ready, call meâ€. Thatâ€™s async callback.

```javascript
setTimeout(() => {
  console.log("Food is ready!");
}, 2000);
```

- The arrow function is a callback.

### Sync Callback (Immediate)

```javascript
[1, 2, 3].forEach(function(num) {
  console.log(num);
});
```

- Runs immediately. Blocking

### Async Callback (Later)

```javascript
setTimeout(function() {
  console.log("Runs later");
}, 1000);
```

- Runs later, Non-blocking.

### Callback Hell

- When callbacks are nested inside other callbacks, it can become difficult to read and maintain. This is known as
  callback hell.
- You say: After homework â†’ after dinner â†’ after sleep â†’ after wakeupâ€¦ Too many â€œafter after afterâ€

```javascript
setTimeout(() => {
  console.log("Step 1");
  setTimeout(() => {
    console.log("Step 2");
    setTimeout(() => {
      console.log("Step 3");
    }, 1000);
  }, 1000);
}, 1000);
```

## Promises

- A Promise is an object representing the eventual completion or failure of an asynchronous operation.
- Your mom promises you ðŸ«. â€œI will give you chocolate after school.â€
- Right now: Chocolate is not here But promise is given.
- Mom gives chocolate â†’ Fulfilled. âŒ Mom says no â†’ Rejected. â³ Still waiting â†’ Pending. That is exactly a Promise.

### Creating a Promise

```javascript
const promise = new Promise((resolve, reject) => {
  let success = true;

  if (success) {
    resolve("Chocolate ðŸ«");
  } else {
    reject("No chocolate ðŸ˜¢");
  }
});
```

### Using a Promise

```javascript
promise
  .then(result => {
    console.log(result);
  })
  .catch(error => {
    console.log(error);
  })
  .finally(() => {
    console.log("Done");
  });
```

### Why Promises?

- Callbacks were like: â€œAfter thisâ€¦ after thisâ€¦ after thisâ€¦â€ Messy ðŸ˜µ
- Promises make code: Flat, Clean, Easy to read.

### Promise Chaining

```javascript
getFood()
  .then(food => cook(food))
  .then(cookedFood => eat(cookedFood))
  .catch(error => console.log(error));
```

- No nesting , Clean flow

## async/await

- async/await is syntax built on top of Promises to write asynchronous code in a synchronous style.
- Instead of saying: â€œWHEN food comes, THEN eatâ€. You say: â€œWAIT for food ðŸ•, then eat.â€. await means wait here.

```javascript
async function eatFood() {
  const food = await getFood();
  console.log("Eating", food);
}
```

- await only works inside async
- async function always returns a Promise
- Errors handled with try/catch

### Error Handling

```javascript
async function run() {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (err) {
    console.log("Error:", err);
  }
}
```

- async/await is NOT magic. It is Promises + then() behind the scenes.

```javascript
async function demo() {
  console.log("Start");
  await Promise.resolve();
  console.log("End");
}

// Internal it becomes like this

function demo() {
  return Promise.resolve()
    .then(() => {
      console.log("Start");
      return Promise.resolve();
    })
    .then(() => {
      console.log("End");
    });
}
```

## What happens when await is hit?

- Function pauses, Promise is returned, Remaining code goes to Microtask Queue, Event Loop resumes it later.

## async/await + Event Loop

```javascript
console.log("A");

async function test() {
  console.log("B");
  await Promise.resolve();
  console.log("C");
}

test();
console.log("D");
```

- output

```text
A
B
D
C
```

- Because await pushes code to microtask queue

### Promise:

- A Promise represents a future value of an asynchronous operation.

### async/await:

- async/await is syntactic sugar over Promises that makes async code look synchronous.

### await:

- await pauses execution until the Promise settles.