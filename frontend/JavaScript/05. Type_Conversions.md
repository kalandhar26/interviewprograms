# 4. Core Language Features

## 4.1 Type Conversion

- Type conversion means changing the type of value

### 1. Explicit Conversion

- Manual type change using functions like String(), Number(), Boolean(), parseInt().
- we tell JavaScript clearly to change the type.

```javascript
let num = 42;
let str = String(num);   // "42"
let bool = Boolean(0);   // false
let int = parseInt("10px", 10); // 10
```

### 2 Implicit Conversion

- JS auto-converts (coercion) in ops, like + for concat vs add.
- JavaScript automatically changes type by guessing.

```javascript
console.log(1 + "2");    // "12" (string concat)
console.log(1 + true);   // 2 (true → 1)
```l̥

```javascript
// Explicit (manual)
String(123); // "123"
Number("42"); // 42
Boolean(1); // true
parseInt("10px"); // 10
+"3.14"; // 3.14 (unary plus)

// Implicit (automatic)
"5" + 2; // "52" (string concatenation)
"5" - 2; // 3 (numeric subtraction)
if ("hello") { } // true (truthy)
```

## 4.2 Equality

- == loose (coerces types); Changes types before comparing.
- === strict (no coercion); Checks value AND type

```javascript
// Strict equality (✅ ALWAYS USE THIS)
1 === 1; // true
1 === "1"; // false

// Loose equality (❌ AVOID)
1 == 1; // true
1 == "1"; // true (type coercion)
0 == false; // true
"" == false; // true
null == undefined; // true

// Object comparison
{} === {}; // false (different references)

console.log(1 == "1");   // true (coerced)
console.log(1 === "1");  // false
```

## 4.3 Loops

- Repeat code. while/do-while: condition-based; for: counter; for...in: object keys; for...of: iterables; break/continue
  control flow.

### For

```javascript
// for loop
for (let i = 0; i < 5; i++) {
  if (i === 2) continue; // Skip iteration
  if (i === 4) break; // Exit loop
  console.log(i);
}
```

### While

```javascript
let count = 0;
while (count < 3) {
  console.log(count++);
}
```

### Do-While

```javascript
// do...while (executes at least once)
let x = 0;
do {
  console.log(x++);
} while (x < 3);
```

### For...In

```javascript
// for...in (object properties)
const obj = {a: 1, b: 2};
for (let key in obj) {
  console.log(key, obj[key]);
}
```

### For...Of

```javascript
// for...of (iterable values)
const arr = [10, 20, 30];
for (let value of arr) {
  console.log(value);
}

// Array methods (prefer over loops)
arr.forEach(value => console.log(value));
```

## 4.4 Control Flow

- Decision-making. if/else: conditions; switch: multi-case; try/catch: error handling; throw: custom errors.

### if / else

```javascript
// if...else
const score = 85;
if (score >= 90) {
  grade = "A";
} else if (score >= 80) {
  grade = "B";
} else {
  grade = "C";
}
```

### switch

```javascript
// switch (use for multiple exact matches)
const day = "Monday";
switch (day) {
  case "Monday":
    console.log("Start week");
    break;
  case "Friday":
    console.log("Weekend!");
    break;
  default:
    console.log("Midweek");
}
```

### try...catch

```javascript
// try...catch
try {
  JSON.parse("invalid json");
} catch (error) {
  console.error("Parse failed:", error.message);
} finally {
  console.log("Always executes");
}

// throw
function validateAge(age) {
  if (age < 0) throw new Error("Age cannot be negative");
  return age;
}
```

## 4.5 Functions

### Function declaration (hoisted)

```javascript
function multiply(a, b) {
  return a * b;
}
```

### Function expression

```javascript
const divide = function(a, b) {
  return a / b;
};

```

### Arrow function (no 'this' binding)

```javascript
const add = (a, b) => a + b;
const square = x => x * x;
const greet = () => console.log("Hello");

```

### Parameters and arguments

```javascript
// 
function sum(...numbers) { // Rest parameters
  return numbers.reduce((acc, n) => acc + n, 0);
}
sum(1, 2, 3, 4); // 10

```

### Default parameters

```javascript
function greet(name = "Guest") {
  return `Hello, ${name}`;
}
```

### Rest Parameters

```javascript
function sum(...nums) {
  return nums.length;
}
```

## 4.6 Expressions and Operators

- Values/computations.
- Operators: + - * / % arithmetic; !== === != !== < > comparison; && || ! logical; = += assignment; ?.
- Special Operators : ( ?? (nullish) , ?. (safe access), obj?.name (no error))
- optional chaining (ES2020).

```javascript
let a = 5, b = 3;
console.log(a + b);      // 8
console.log(a > b && b); // true (short-circuit)
let c = a ?? "default";  // 5 (nullish)
console.log(obj?.prop);  // Safe access
```

## 4.7 Functions (Declarations, Expressions, Calling, Parameters/Arguments, Scope, Arrow Functions)

- Reusable code blocks.
- Declaration: function name(){} (hoisted);
- Expression: const fn = function(){}; (stored in variable)
- Arrow: () => {} (ES6, lexical this). (Short and Modern)
- Params: inputs; args: passed values.

```javascript
function decl(x) { return x * 2; }  // Hoisted

const expr = function(y) { return y + 1; };

const arrow = (z) => z - 1;  // Concise

console.log(decl(5));  // 10
```

# 5. Destructuring and Spread / Rest

- Unpack/expand iterables/objects.

```javascript
const {name, age} = {name: "Alice", age: 30};  // Destructure
const [first] = [1,2,3];  // First elem
const all = [...[1,2], 3];  // Spread
function sum(...nums) { return nums.reduce((a,b)=>a+b); }  // Rest
```

## Destructing means taking out the values

```javascript
const {name} = {name: "Ali"};
const [first] = [1, 2, 3];
```

## Spread means expanding the values

```javascript
const arr = [...[1,2], 3];
```

## Rest means collecting remaining values

```javascript
function sum(...nums) { }
```


