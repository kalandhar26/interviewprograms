## 1. Nested Functions & Lexical Scoping
- Functions inside functions, accessing parent's scope.
- Functions inside functions, inheriting outer scope.
- Inner functions access outer vars by lexical (code position) scope, not call site.

```javascript
function outer() {
  const outerVar = "I'm outside";
  
  function inner() {
    const innerVar = "I'm inside";
    console.log(outerVar); // ✅ Can access parent scope
    return innerVar;
  }
  
  // console.log(innerVar); // ❌ Cannot access child scope
  return inner();
}

// Lexical scoping = determined by where function is declared
let x = "global";
function outer() {
    let x = "outer";
    function inner() { console.log(x); }  // "outer"
    inner();
}

```

## 2. IIFE (Immediately Invoked Function Expression)
- Self-executing anon function for private scope (ES5 pattern).

- **When to use:**
- Creating private scope (pre-modules)
- Avoiding global pollution
- One-time initialization

```javascript
// Classic IIFE
(function() {
  const privateVar = "Secret";
  console.log("Runs immediately");
})();// Runs Immediately

// Arrow IIFE
(() => {
  console.log("Modern IIFE");
})();

// With parameters
((name) => {
  console.log(`Hello ${name}`);
})("Alice");
```

## 3. Revealing Module Pattern
- IIFE returning object with public methods, hiding privates (ES5 modules).

- **When to use:**
- Before ES6 modules
- Creating encapsulated components
- Library patterns
  l̥
```javascript
const counterModule = (function() {
  // Private state
  let count = 0;
  
  // Private function
  function logChange() {
    console.log(`Count changed to: ${count}`);
  }
  
  // Public API
  return {
    increment() {
      count++;
      logChange();
      return count;
    },
    decrement() {
      count--;
      logChange();
      return count;
    },
    getCount() {
      return count;
    }
  };
})();

counterModule.increment(); // Count changed to: 1
// counterModule.count; // undefined (private)
```