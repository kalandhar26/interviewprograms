# JavaScript Call Stack

- Imagine Javascript as single lane highway, where cars (functions) drive one behind the other in a strict order. This
  highway is called * call stack*
- JS keeps track of what code is running right now and what needs to run next.
- JS is single-threaded, meaning it can handle one thing at a time -- no multitasking like multilane freeway.

## How JS Works (Step by Step)

- **Empty Start:** When your script begins, the call stack is empty. The first "car" to enter is the global execution
  context (like the main program starting point).
- **Pushing Functions:** Every time you call a function, JavaScript "pushes" it onto the stack—like adding a new car
  behind the current one. This new function gets its own execution context, which includes:
    1. Local variables (stuff defined inside the function).
    2. Scope (access to outer variables).
    3. The function's code being run.

```javascript
function greet(name) {
  console.log("Hello, " + name);  // This runs now
}

greet("Alice");  // Pushes 'greet' onto the stack
```

    4. Stack now: [Global Context, greet("Alice")]

- **Nested Calls:** If greet calls another function, say sayBye(), that gets pushed on top. The stack
  grows: [Global, greet, sayBye]. JavaScript pauses greet until sayBye finishes.
- **Popping Off:** When a function finishes (returns or ends), it's "popped" off the stack—like the car driving away.
  Control goes back to the previous function.
    1. After sayBye ends: Stack = [Global, greet]
    2. After greet ends: Stack = [Global]
- **LIFO Rule:** It's Last In, First Out (like a stack of plates—you add/remove from the top). This ensures functions
  run in
  the exact order they're called, preventing chaos.

### Why It Matters (Technically):

- **Recursion:** If a function calls itself too deeply (e.g., factorial(10000)), the stack overflows—crash! (Error: "
  Maximum
  call stack size exceeded").
- **Async Code:** The call stack is synchronous. For promises/async/await, unfinished tasks get offloaded to the event
  loop (a
  queue outside the stack) and pushed back when ready.
- In short, the call stack is JavaScript's to-do list for execution—simple, orderly, but it hates infinite loops.

# JavaScript Memory: Where Your Data Lives

- Think of memory as JavaScript's warehouse for storing data. Unlike languages like C++ where you manually allocate/free
  memory, JS does most of it automatically via a garbage collector. But it's split into two main areas:
    1. Stack (for quick, temporary stuff)
    2. Heap (for big, flexible data). This setup keeps things fast and organized.

## The Two Zones:

### Stack Memory (The Fast Lane):

- **What Goes Here:** Primitive values (numbers, strings, booleans, null, undefined) and references to heap objects.
  Also, function execution contexts (from the call stack).
- **Why Stack?:** It's small, fixed-size, and superfast like a notepad for quick notes. Data here is short-lived (pops
  when function ends).
- **Size Limit:** Tiny (a few MB), so no big arrays here.

```javascript
let num = 42;  // '42' stored directly on stack
let objRef = { key: 'value' };  // Reference (pointer) on stack; actual object on heap
```

### Heap Memory (The Big Storage):

- What Goes Here: Objects, arrays, functions—anything dynamic or complex that can grow/shrink.
- Why Heap?: It's larger and flexible, like a giant warehouse. Access is slower than stack (via references), but
  handles massive data.
- References Rule: Variables on the stack hold "pointers" to heap data. Change the object via one reference, and all
  see the update.

```javascript
let person1 = { name: 'Bob' };  // Object on heap
let person2 = person1;         // person2 points to same heap spot
person2.name = 'Alice';        // person1.name is now 'Alice' too!
```

### Garbage Collection: Auto-Cleanup

- JS's engine (e.g., V8 in Chrome) runs a garbage collector periodically to free unused memory.
- **How?:** Tracks "reachable" objects (anything referenced from stack/global). If unreferenced (no pointers), it's "
  garbage" and gets deleted.
- **Mark-and-Sweep:** Engine marks live objects, sweeps the rest. Happens in pauses (minor hiccups), but modern JS
  minimizes this.
- **Memory Leaks:** Watch out—forgotten references (e.g., event listeners) keep objects alive forever, bloating memory.
  Use dev tools (Chrome: Memory tab) to profile.

### Key Technical Notes:

- Primitives vs. Objects: Primitives are copied by value (stack duplication). Objects by reference (shared heap
  pointer).
- Closures: Inner functions "capture" outer variables by keeping their stack context alive in the heap—powerful but can
  leak if overused.
- Performance Tip: Favor stack for speed (primitives), heap for flexibility (objects). Monitor with performance.memory
  API.

========================

# EventLoop

- JavaScript is single‑threaded — only one thing runs at a time on the call stack. If async tasks like fetch() or
  setTimeout() were handled synchronously, the browser would freeze.
- The event loop solves this by acting like a traffic cop: it decides when async tasks can safely enter the stack
  without blocking ongoing work.

## The Key Players

### Call Stack (Execution Stack)

- Where synchronous code runs.
- Operates in LIFO (last in, first out).
- Example: function calls, loops, calculations.

### Web APIs / Host APIs

- Provided by the browser (DOM events, timers, AJAX) or Node.js  (file system, timers).
- They handle async work outside the JS engine.
- Example: setTimeout(() => {...}, 1000) is delegated to the browser timer system.

### Callback Queue (Macrotask Queue)

- Holds completed async tasks waiting to run.
- Examples: setTimeout, setInterval, setImmediate (Node), DOM events.
- Processed after microtasks and only when the stack is empty.

### Microtask Queue (High Priority Queue)

- Special queue for promises and microtasks.
- Examples: Promise.then(), catch(), finally(), queueMicrotask(), process.nextTick() (Node).
- Always drained fully before moving to the callback queue.
- That’s why promises often resolve “faster” than timers.

### Event Loop

- The Event Loop is a mechanism in JavaScript runtime that allows JavaScript (single-threaded) to perform non-blocking
  asynchronous operations.
- It continuously checks:
    1. Call Stack (is it empty?)
    2. Task Queue / Microtask Queue (are callbacks waiting?)
    3. When the stack is empty, it pushes queued tasks into the stack for execution.
- This mechanism enables JavaScript to handle asynchronous operations efficiently without blocking the main thread.
- It is essential for building responsive and efficient JavaScript applications, especially those that involve
  asynchronous operations like API calls, file I/O, and user interactions.

### Priority Rules

#### Microtasks > Macrotasks

- After each macrotask finishes, the event loop drains the microtask queue completely before moving on.
- This ensures promises resolve quickly and consistently.

#### Rendering/UI Updates

- Typically happen after microtasks are cleared but before the next macrotask.
- That’s why heavy microtask chains can delay rendering.

## EventLoop

- JavaScript is single‑threaded, so it uses the event loop to handle asynchronous tasks without blocking execution.
- The event loop constantly checks the call stack. If it’s empty, it first drains the microtask queue — which includes
  promises and process.nextTick() — and then processes one task from the callback queue, like a setTimeout or DOM event.
- This priority system ensures promises resolve faster than timers, keeping applications responsive.
- In short, the event loop bridges synchronous execution with asynchronous events, acting like a traffic cop that keeps
  everything moving smoothly.