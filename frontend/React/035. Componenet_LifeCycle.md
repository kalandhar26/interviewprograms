# Component Life Cycle

- Imagine a human life ðŸ‘¶âž¡ï¸ðŸ§‘âž¡ï¸ðŸ‘´.You are born, You grow, learn, and change
- One day, you leave. A React component also has a life:
- It comes to life (mounts). It changes when data changes (updates)
- It goes away (unmounts)
- Earlier, React used class lifecycle methods.
- Now with Hooks, the same lifecycle is managed using useEffect, useState, and useRef

## Professional Definition

- Component Lifecycle with Hooks refers to managing a componentâ€™s mounting, updating, and unmounting phases using React
  Hooks like useEffect, useState, and cleanup functions instead of class lifecycle methods.

| Lifecycle Phase | Hook Used                           |
|-----------------|-------------------------------------|
| Mount           | `useEffect(() => {}, [])`           |
| Update          | `useEffect(() => {}, [deps])`       |
| Unmount         | Cleanup function inside `useEffect` |

| Class Component      | Hook Equivalent                  |
|----------------------|----------------------------------|
| componentDidMount    | `useEffect(() => {}, [])`        |
| componentDidUpdate   | `useEffect(() => {}, [deps])`    |
| componentWillUnmount | `return () => {}` in `useEffect` |

### Full Lifecycle Using Hooks

```jsx
import React, { useEffect, useState } from "react";

function LifeCycleDemo() {
  const [count, setCount] = useState(0);

  // Mount & Update
  useEffect(() => {
    console.log("Component Mounted or Updated");

    return () => {
      console.log("Component Unmounted");
    };
  }, [count]);

  return (
    <>
      <h2>Count: {count}</h2>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </>
  );
}

export default LifeCycleDemo;
```

### Common Lifecycle Patterns with Hooks

#### Run Once (Mount Only)

```jsx
useEffect(() => {
  console.log("Mounted");
}, []);
```

#### Run on State/Prop Change

```jsx
useEffect(() => {
  console.log("Count changed");
}, [count]);
```

#### Cleanup on Unmount

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log("Running...");
  }, 1000);

  return () => clearInterval(timer);
}, []);
```

# StrictMode lifecycle behavior (React 18)

- Imagine a teacher checking homework ðŸ“š. The teacher makes you do the same homework twice
- Not to punish you ðŸ˜„, But to find mistakes you didnâ€™t notice
- React StrictMode works the same way.
- In development mode, React intentionally runs some lifecycle logic twice
- It helps catch: Bugs, Side effects, Memory leaks
- This happens only in development, never in production.

## Professional Definition

- React StrictMode in React 18 intentionally double-invokes certain lifecycle behaviors (mount, unmount, effects) in
  development mode to detect unsafe side effects and ensure components are resilient to future concurrent rendering
  features.

### What Exactly Runs Twice in React 18 StrictMode?

ðŸ” React Simulates This Sequence:

```html
Mount
â†’ Run Effects
â†’ Cleanup Effects
â†’ Mount Again
â†’ Run Effects Again
```

### StrictMode Effect Behavior

```jsx
import React, { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Effect runs");

    return () => {
      console.log("Cleanup runs");
    };
  }, []);

  return <h2>Hello StrictMode</h2>;
}

export default Demo;
```

- console output

```text
Effect runs
Cleanup runs
Effect runs
```

## Pure Component

- A Pure Component is a React component that performs a shallow comparison of props and state and re-renders only when a
  change is detected, preventing unnecessary renders and improving performance.
- Pure components optimize rendering by preventing unnecessary re-renders using shallow comparison of props and state.

| Feature     | Normal Component | Pure Component             |
|-------------|------------------|----------------------------|
| Re-render   | Always           | Only if props/state change |
| Comparison  | None             | Shallow                    |
| Performance | Average          | Better                     |
| Use case    | Default          | Optimization               |

### Pure Component (Class-Based)

```jsx
import React, { PureComponent } from "react";

class Counter extends PureComponent {
  render() {
    console.log("Rendered");
    return <h1>{this.props.count}</h1>;
  }
}
```

- React compares prevProps vs nextProps shallowly.

### Pure Component (Functional Based)

```jsx
const Counter = React.memo(({ count }) => {
  console.log("Rendered");
  return <h1>{count}</h1>;
});
```

- Same behavior as PureComponent