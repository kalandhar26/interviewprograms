# Component Life Cycle

- Imagine a human life ðŸ‘¶âž¡ï¸ðŸ§‘âž¡ï¸ðŸ‘´.You are born, You grow, learn, and change
- One day, you leave. A React component also has a life:
- It comes to life (mounts). It changes when data changes (updates)
- It goes away (unmounts)
- Earlier, React used class lifecycle methods.
- Now with Hooks, the same lifecycle is managed using useEffect, useState, and useRef

## Professional Definition

- Component Lifecycle with Hooks refers to managing a componentâ€™s mounting, updating, and unmounting phases using React
  Hooks like useEffect, useState, and cleanup functions instead of class lifecycle methods.

| Lifecycle Phase | Hook Used                           |
|-----------------|-------------------------------------|
| Mount           | `useEffect(() => {}, [])`           |
| Update          | `useEffect(() => {}, [deps])`       |
| Unmount         | Cleanup function inside `useEffect` |

| Class Component      | Hook Equivalent                  |
|----------------------|----------------------------------|
| componentDidMount    | `useEffect(() => {}, [])`        |
| componentDidUpdate   | `useEffect(() => {}, [deps])`    |
| componentWillUnmount | `return () => {}` in `useEffect` |

### Full Lifecycle Using Hooks

```jsx
import React, { useEffect, useState } from "react";

function LifeCycleDemo() {
  const [count, setCount] = useState(0);

  // Mount & Update
  useEffect(() => {
    console.log("Component Mounted or Updated");

    return () => {
      console.log("Component Unmounted");
    };
  }, [count]);

  return (
    <>
      <h2>Count: {count}</h2>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </>
  );
}

export default LifeCycleDemo;
```

### Common Lifecycle Patterns with Hooks

#### Run Once (Mount Only)

```jsx
useEffect(() => {
  console.log("Mounted");
}, []);
```

#### Run on State/Prop Change

```jsx
useEffect(() => {
  console.log("Count changed");
}, [count]);
```

#### Cleanup on Unmount

```jsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log("Running...");
  }, 1000);

  return () => clearInterval(timer);
}, []);
```

# StrictMode lifecycle behavior (React 18)

- Imagine a teacher checking homework ðŸ“š. The teacher makes you do the same homework twice
- Not to punish you ðŸ˜„, But to find mistakes you didnâ€™t notice
- React StrictMode works the same way.
- In development mode, React intentionally runs some lifecycle logic twice
- It helps catch: Bugs, Side effects, Memory leaks
- This happens only in development, never in production.

## Professional Definition

- React StrictMode in React 18 intentionally double-invokes certain lifecycle behaviors (mount, unmount, effects) in
  development mode to detect unsafe side effects and ensure components are resilient to future concurrent rendering
  features.

### What Exactly Runs Twice in React 18 StrictMode?
ðŸ” React Simulates This Sequence:
```html
Mount
â†’ Run Effects
â†’ Cleanup Effects
â†’ Mount Again
â†’ Run Effects Again
```

### StrictMode Effect Behavior
```jsx
import React, { useEffect } from "react";

function Demo() {
  useEffect(() => {
    console.log("Effect runs");

    return () => {
      console.log("Cleanup runs");
    };
  }, []);

  return <h2>Hello StrictMode</h2>;
}

export default Demo;
```
- console output

```text
Effect runs
Cleanup runs
Effect runs
```