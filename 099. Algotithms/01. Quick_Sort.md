# Quick Sort

- Quick Sort is a highly efficient, divide-and-conquer sorting algorithm that selects a 'pivot' element from the array
  and partitions the other elements into two sub-arrays: one with elements less than the pivot and one with elements
  greater. It then recursively sorts the sub-arrays. Developed by Tony Hoare in 1959, it's one of the fastest in-place
  sorting algorithms in practice, though its worst-case performance can degrade if pivots are poorly chosen (e.g.,
  always the first/last element in a sorted array).

## Key Characteristics:

- Best Case: O(n log n) – Balanced partitions (pivot is median).
- Average Case: O(n log n) – Random or good pivot selection.
- Worst Case: O(n²) – Poor pivots (e.g., already sorted array with first element as pivot); mitigated by randomizing
  pivot.
- Space Complexity: O(log n) – Recursion stack depth.
- Pros: In-place (no extra array needed); cache-friendly; very fast on average.
- Cons: Unstable (doesn't preserve relative order of equal elements); worst-case quadratic time without pivot
  randomization.

## How It Works (Step-by-Step):

- Choose Pivot: Select an element (e.g., last element or random) as pivot.
- Partition: Rearrange the array so elements < pivot are on the left, > pivot on the right, and pivot in its final
  sorted position. Return the pivot's index.
- Recurse: Apply Quick Sort to the left sub-array (elements before pivot) and right sub-array (elements after pivot).
- Base Case: If sub-array size ≤ 1, it's already sorted—no recursion needed.
- Repeat until the entire array is sorted.
- For pivot selection, the Lomuto partition scheme is common and simple: it uses two pointers (one for scanning, one for
  swapping).


```java
import java.util.Arrays;

public class QuickSort {
    
    // Main Quick Sort method: sorts the sub-array from low to high
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {  // Base case: more than one element
            // Partition and get pivot index
            int pivotIndex = partition(arr, low, high);
            
            // Recursively sort left and right sub-arrays
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    // Lomuto Partition: places pivot in correct position
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];  // Choose last element as pivot
        int i = low - 1;  // Index of smaller element
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {  // If current element <= pivot
                i++;  // Increment index of smaller element
                // Swap arr[i] and arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        
        // Swap pivot with i+1 (final position of pivot)
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;
        
        return i + 1;  // Return pivot's index
    }
    
    // Public wrapper for full array
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    public static void main(String[] args) {
        // Example unsorted array
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        
        // Print original array
        System.out.println("Original Array: " + Arrays.toString(numbers));
        
        // Perform Quick Sort
        quickSort(numbers);
        
        // Print sorted array
        System.out.println("Sorted Array: " + Arrays.toString(numbers));
    }
}
```

- output

```text
Original Array: [64, 34, 25, 12, 22, 11, 90]
Sorted Array: [11, 12, 22, 25, 34, 64, 90]
```