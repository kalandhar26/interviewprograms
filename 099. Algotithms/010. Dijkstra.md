# Dijkstra's Algorithm

- Dijkstra's finds the shortest path from a source to all nodes in a weighted graph with non-negative edges, using a
  priority queue to always expand the cheapest path first.

## Key Characteristics:

- Time Complexity: O((V + E) log V) with binary heap.
- Space Complexity: O(V).
- Pros: Optimal for non-negative weights; single-source shortest paths.
- Cons: Fails with negative weights; not for unweighted graphs (use BFS).

## How It Works (Step-by-Step):

- Initialize distances: source=0, others=∞.
- Priority queue: Insert (source, 0).
- While queue not empty: Extract min-distance node u.
- For each neighbor v of u: If dist[v] > dist[u] + weight(u,v), update dist[v] and enqueue.
- Skip if already finalized (via visited/dist check).

- Uses PriorityQueue with custom pair class for (distance, node).

```java
import java.util.*;

class Pair implements Comparable<Pair> {
    int node, dist;

    Pair(int n, int d) {
        node = n;
        dist = d;
    }

    public int compareTo(Pair other) {
        return this.dist - other.dist;
    }
}

public class Dijkstras {
    public static int[] dijkstra(List<List<int[]>> graph, int start) {  // Returns dist array
        int n = graph.size();
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;

        PriorityQueue<Pair> pq = new PriorityQueue<>();
        pq.add(new Pair(start, 0));

        while (!pq.isEmpty()) {
            Pair p = pq.poll();
            int u = p.node;

            if (p.dist > dist[u]) continue;  // Skip outdated

            for (int[] edge : graph.get(u)) {
                int v = edge[0], weight = edge[1];
                if (dist[v] > dist[u] + weight) {
                    dist[v] = dist[u] + weight;
                    pq.add(new Pair(v, dist[v]));
                }
            }
        }
        return dist;
    }

    public static void main(String[] args) {
        // Graph: 0-1(w=4), 0-2(w=2), 1-2(w=1), 1-3(w=5), 2-3(w=8)
        List<List<int[]>> graph = new ArrayList<>();
        for (int i = 0; i < 4; i++) graph.add(new ArrayList<>());
        graph.get(0).add(new int[]{1, 4});
        graph.get(0).add(new int[]{2, 2});
        graph.get(1).add(new int[]{0, 4});
        graph.get(1).add(new int[]{2, 1});
        graph.get(1).add(new int[]{3, 5});
        graph.get(2).add(new int[]{0, 2});
        graph.get(2).add(new int[]{1, 1});
        graph.get(2).add(new int[]{3, 8});
        graph.get(3).add(new int[]{1, 5});
        graph.get(3).add(new int[]{2, 8});

        int[] distances = dijkstra(graph, 0);
        System.out.println("Distances from 0: " + Arrays.toString(distances));
    }
}
```

- output

```text
Distances from 0: [0, 3, 2, 8]
```

- (Paths: 0→2 (2), 0→2→1 (3), 0→2→1→3 (8).)
- **Edge Cases:**
- No Path: dist=∞ (MAX_VALUE).
- Single Node: dist[start]=0.
- Equal Weights: Handles ties via queue.