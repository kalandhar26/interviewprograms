# Breadth-First Search (BFS)

- BFS explores a graph level by level, starting from a source node, using a queue. It's ideal for shortest paths in
  unweighted graphs or finding connected components.

## Key Characteristics:

- Time Complexity: O(V + E) – Visits each vertex (V) and edge (E) once.
- Space Complexity: O(V) – For queue and visited set.
- Pros: Finds shortest path in unweighted graphs; level-order traversal.
- Cons: Memory-heavy for wide graphs.

## How It Works (Step-by-Step):

- Enqueue the source node and mark it visited.
- While queue is not empty: Dequeue a node, process it (e.g., print).
- Enqueue all unvisited neighbors, mark them visited.
- Repeat, ensuring level-by-level expansion.

```java
import java.util.*;

public class BFS {
    public static void bfs(List<List<Integer>> graph, int start) {
        int n = graph.size();
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();

        queue.add(start);
        visited[start] = true;

        while (!queue.isEmpty()) {
            int node = queue.poll();
            System.out.print(node + " ");  // Process node

            for (int neighbor : graph.get(node)) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.add(neighbor);
                }
            }
        }
    }

    public static void main(String[] args) {
        // Graph: 0-1, 0-2, 1-2, 1-3, 2-3 (adjacency list)
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < 4; i++) graph.add(new ArrayList<>());
        graph.get(0).addAll(Arrays.asList(1, 2));
        graph.get(1).addAll(Arrays.asList(0, 2, 3));
        graph.get(2).addAll(Arrays.asList(0, 1, 3));
        graph.get(3).addAll(Arrays.asList(1, 2));

        bfs(graph, 0);  // Start from node 0
    }
}
```

- output

```text
0 1 2 3
```

- Visits in level order: 0, then 1&2, then 3.
- **Edge Cases:**
- Disconnected Graph: Won't visit isolated nodes.
- Single Node: Just prints the start.
- Cycle: Handles via visited array (no infinite loop).