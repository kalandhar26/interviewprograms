
```java
import java.util.*;

public class BMSSP {
    static class Edge {
        int to;
        double w;
        Edge(int to, double w) {
            this.to = to;
            this.w = w;
        }
    }

    static List<List<Edge>> graph;
    static double[] dist;
    static int[] pred;
    static int n, k, t;

    // Union-Find for pivot forest roots
    static class UnionFind {
        int[] parent;
        UnionFind(int size) {
            parent = new int[size];
            for (int i = 0; i < size; i++) parent[i] = i;
        }
        int find(int x) {
            return parent[x] == x ? x : (parent[x] = find(parent[x]));
        }
        void union(int x, int y) {
            int px = find(x), py = find(y);
            if (px != py) parent[px] = py;
        }
    }

    // Simplified BlockList using TreeMap<Double, List<Integer>> (naive log n ops)
    static class BlockList {
        TreeMap<Double, List<Integer>> map = new TreeMap<>();
        int M;

        BlockList(int m) { M = m; }

        void insert(double key, int value) {
            map.computeIfAbsent(key, k -> new ArrayList<>()).add(value);
        }

        void batchPrepend(List<Pair> items) {  // Simplified: just insert
            for (Pair p : items) insert(p.d, p.v);
        }

        Object[] pull() {  // Returns {B_i, S_i} where |S_i| <= M, B_i = next key after pulled
            List<Integer> S_i = new ArrayList<>();
            double B_i = map.isEmpty() ? Double.POSITIVE_INFINITY : map.firstKey();
            if (map.isEmpty()) return new Object[]{B_i, S_i};

            Iterator<Map.Entry<Double, List<Integer>>> it = map.entrySet().iterator();
            while (S_i.size() < M && it.hasNext()) {
                Map.Entry<Double, List<Integer>> entry = it.next();
                double key = entry.getKey();
                if (key >= B_i) B_i = key;  // Update separator
                S_i.addAll(entry.getValue());
                it.remove();
            }
            return new Object[]{B_i, S_i};
        }
    }

    // Pair for priority queue
    static class Pair implements Comparable<Pair> {
        int v;
        double d;
        Pair(int v, double d) {
            this.v = v;
            this.d = d;
        }
        public int compareTo(Pair o) {
            return Double.compare(d, o.d);
        }
    }

    // Algorithm 2: BaseCase (mini-Dijkstra up to k+1 nodes)
    static Object[] baseCase(double B, int x) {
        PriorityQueue<Pair> H = new PriorityQueue<>();
        H.add(new Pair(x, dist[x]));
        Set<Integer> inH = new HashSet<>();
        inH.add(x);
        List<Integer> U0 = new ArrayList<>();
        U0.add(x);

        while (!H.isEmpty() && U0.size() < k + 1) {
            Pair p = H.poll();
            int u = p.v;
            inH.remove(u);
            U0.add(u);  // Add after poll to avoid dups

            for (Edge e : graph.get(u)) {
                int v = e.to;
                double newD = dist[u] + e.w;
                if (newD < dist[v] && newD < B) {
                    dist[v] = newD;
                    pred[v] = u;
                    if (!inH.contains(v)) {
                        H.add(new Pair(v, dist[v]));
                        inH.add(v);
                    }  // Note: Full impl needs decrease-key; here we insert new (lazy)
                }
            }
        }

        double Bp = (U0.size() <= k) ? B : Collections.max(U0, Comparator.comparingDouble(v -> dist[v]));
        List<Integer> U = new ArrayList<>();
        for (int v : U0) {
            if (dist[v] < Bp) U.add(v);
        }
        return new Object[]{Bp, U};
    }

    // Algorithm 1: FindPivots (simplified: k relaxations + forest pivots)
    static Object[] findPivots(double B, List<Integer> S) {
        int wSize = 0;
        Set<Integer> W = new HashSet<>();  // Working set
        UnionFind uf = new UnionFind(n);

        // k steps of relaxation from S, collect updates in W
        for (int step = 0; step < k; step++) {
            List<Integer> currentS = new ArrayList<>(S);
            for (int u : currentS) {
                for (Edge e : graph.get(u)) {
                    int v = e.to;
                    double newD = dist[u] + e.w;
                    if (newD < dist[v] && newD < B) {
                        dist[v] = newD;
                        pred[v] = u;
                        if (!W.contains(v)) {
                            W.add(v);
                            wSize++;
                        }
                        uf.union(v, u);  // Build forest via pred
                    }
                }
            }
        }

        if (wSize > k * S.size()) {
            return new Object[]{S, new ArrayList<>()};  // No reduction
        }

        // Select pivots: roots of trees with >=k vertices (simplified count)
        List<Integer> P = new ArrayList<>();
        Map<Integer, Integer> treeSizes = new HashMap<>();
        for (int v : W) {
            int root = uf.find(v);
            treeSizes.put(root, treeSizes.getOrDefault(root, 0) + 1);
        }
        for (Map.Entry<Integer, Integer> entry : treeSizes.entrySet()) {
            if (entry.getValue() >= k && S.contains(entry.getKey())) {
                P.add(entry.getKey());
            }
        }

        List<Integer> workingSet = new ArrayList<>(W);
        return new Object[]{P, workingSet};
    }

    // Algorithm 3: BMSSP (recursive)
    static Object[] bmssp(int l, double B, List<Integer> S) {
        if (l == 0) {
            return baseCase(B, S.get(0));  // Assume |S|=1
        }

        Object[] pivots = findPivots(B, S);
        List<Integer> P = (List<Integer>) pivots[0];
        List<Integer> W = (List<Integer>) pivots[1];

        BlockList D = new BlockList((int) Math.pow(2, (l - 1) * t));
        for (int x : P) {
            D.insert(dist[x], x);
        }

        int i = 0;
        double B0 = P.isEmpty() ? B : Collections.min(P, Comparator.comparingDouble(v -> dist[v]));
        List<Integer> U = new ArrayList<>();

        while (U.size() < k * (int) Math.pow(2, l * t) && !D.map.isEmpty()) {
            i++;
            Object[] pulled = D.pull();
            double B_i = (Double) pulled[0];
            List<Integer> S_i = (List<Integer>) pulled[1];

            Object[] rec = bmssp(l - 1, B_i, S_i);
            double B_i_prime = (Double) rec[0];
            List<Integer> U_i = (List<Integer>) rec[1];
            U.addAll(U_i);

            // Relax edges from U_i
            List<Pair> K = new ArrayList<>();
            for (int u : U_i) {
                for (Edge e : graph.get(u)) {
                    int v = e.to;
                    double newD = dist[u] + e.w;
                    if (newD < dist[v]) {
                        dist[v] = newD;
                        pred[v] = u;
                        if (B_i <= newD && newD < B) {
                            D.insert(newD, v);
                        } else if (B_i_prime <= newD && newD < B_i) {
                            K.add(new Pair(v, newD));
                        }
                    }
                }
            }

            // Batch prepend K + old S_i with B_i_prime <= dist < B_i
            for (int x : S_i) {
                if (B_i_prime <= dist[x] && dist[x] < B_i) {
                    K.add(new Pair(x, dist[x]));
                }
            }
            D.batchPrepend(K);
        }

        double B_prime = B0;
        for (int j = 1; j <= i; j++) {  // Simplified: track min B'_i
            // In full: B_prime = min over all B'_i
        }
        U.addAll(W.stream().filter(v -> dist[v] < B_prime).toList());
        return new Object[]{B_prime, U};
    }

    // Initialize and run SSSP from source s
    static double[] computeSSSP(int s) {
        n = graph.size();
        dist = new double[n];
        pred = new int[n];
        Arrays.fill(dist, Double.POSITIVE_INFINITY);
        Arrays.fill(pred, -1);
        dist[s] = 0;
        pred[s] = -1;

        k = (int) Math.floor(Math.pow(n, 1.0 / 3));  // Approx log_{1/3} n
        t = (int) Math.floor(Math.pow(n, 2.0 / 3));  // Approx log_{2/3} n, but paper uses log base

        int l = (int) Math.ceil(Math.log(n) / t);
        List<Integer> S = new ArrayList<>();
        S.add(s);

        bmssp(l, Double.POSITIVE_INFINITY, S);

        return dist;
    }

    public static void main(String[] args) {
        // Sample directed graph: n=5, edges with weights
        n = 5;
        graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());

        // Edges: 0->1 (w=4), 0->2 (2), 1->2 (1), 1->3 (5), 2->3 (8), 2->4 (3), 3->4 (1)
        graph.get(0).add(new Edge(1, 4));
        graph.get(0).add(new Edge(2, 2));
        graph.get(1).add(new Edge(2, 1));
        graph.get(1).add(new Edge(3, 5));
        graph.get(2).add(new Edge(3, 8));
        graph.get(2).add(new Edge(4, 3));
        graph.get(3).add(new Edge(4, 1));

        double[] distances = computeSSSP(0);
        System.out.println("Distances from 0: " + Arrays.toString(distances));
        // Expected: [0.0, 3.0, 2.0, 8.0, 5.0] (via paths like 0-2-4-3? Wait, recalculate: actually 0-2(2)-1? No, directed.
        // Correct shortest: 0:0, 1:4 (direct, or 0-2-1? No edge 2->1), waitâ€”graph has 1->2, not reverse.
        // Paths: 1:4, 2:2, 3: min(4+5=9, 2+8=10)=9, 4: min(9+1=10, 2+3=5)=5
    }
}
```