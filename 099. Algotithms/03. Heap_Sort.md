# Heap Sort

- Heap Sort is a comparison-based sorting algorithm that leverages a binary heap data structure (typically a max-heap)
  to sort an array in ascending order. It first constructs a max-heap from the unsorted array, then iteratively extracts
  the largest element (root) and rebuilds the heap. This ensures O(n log n) time complexity in all cases, making it
  reliable but less cache-efficient than algorithms like Quick Sort.

## Key Characteristics:

- Best/Average/Worst Case: O(n log n) – Heap construction is O(n), and n extractions are each O(log n).
- Space Complexity: O(1) – Fully in-place.
- Pros: Predictable performance; no recursion; useful for heap-based priority queues.
- Cons: Unstable (equal elements may swap positions); not adaptive to pre-sorted data.

## How It Works (Step-by-Step):

- Build Max-Heap: Start from the last non-leaf node and heapify downward to ensure every parent ≥ children (O(n)).
- Sort Phase: For each position from the end to the second element:
- Swap the root (largest) with the current end position.
- Reduce heap size by 1.
- Heapify the new root to maintain the max-heap property (O(log n) per step).
- The sorted portion grows from the end backward.
- The heapify operation bubbles down the largest child if the parent violates the heap property.


```java
import java.util.Arrays;

public class HeapSort {
    
    // Main Heap Sort method
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // Step 1: Build max-heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Step 2: Extract max elements one by one
        for (int i = n - 1; i >= 1; i--) {
            // Swap root with last heap element
            swap(arr, 0, i);
            // Heapify reduced heap
            heapify(arr, i, 0);
        }
    }
    
    // Heapify: Ensure max-heap property for subtree at 'index'
    private static void heapify(int[] arr, int heapSize, int index) {
        int largest = index;
        int leftChild = 2 * index + 1;
        int rightChild = 2 * index + 2;
        
        // Check left child
        if (leftChild < heapSize && arr[leftChild] > arr[largest]) {
            largest = leftChild;
        }
        
        // Check right child
        if (rightChild < heapSize && arr[rightChild] > arr[largest]) {
            largest = rightChild;
        }
        
        // If largest != index, swap and recurse
        if (largest != index) {
            swap(arr, index, largest);
            heapify(arr, heapSize, largest);
        }
    }
    
    // Helper to swap elements
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        
        System.out.println("Original: " + Arrays.toString(numbers));
        heapSort(numbers);
        System.out.println("Sorted: " + Arrays.toString(numbers));
    }
}
```
- output

```text
Original: [64, 34, 25, 12, 22, 11, 90]
Sorted: [11, 12, 22, 25, 34, 64, 90]
```

