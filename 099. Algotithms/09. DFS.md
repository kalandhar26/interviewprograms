# Depth-First Search (DFS)

- DFS dives deep into one branch before backtracking, using a stack (or recursion). It's useful for topological sorting,
  detecting cycles,

## Key Characteristics:

- Time Complexity: O(V + E).
- Space Complexity: O(V) – Recursion stack or explicit stack.
- Pros: Low memory for deep graphs; simple recursive form.
- Cons: Can get stuck in deep paths; not for shortest paths.

## How It Works (Step-by-Step):

- Mark source visited, process it.
- Recur on first unvisited neighbor.
- Backtrack and try next neighbor.
- (Iterative: Use stack to simulate recursion.)

```java
import java.util.*;

public class DFS {
    public static void dfs(List<List<Integer>> graph, int node, boolean[] visited) {
        visited[node] = true;
        System.out.print(node + " ");  // Process node
        
        for (int neighbor : graph.get(node)) {
            if (!visited[neighbor]) {
                dfs(graph, neighbor, visited);
            }
        }
    }
    
    public static void dfsWrapper(List<List<Integer>> graph, int start) {
        boolean[] visited = new boolean[graph.size()];
        dfs(graph, start, visited);
    }
    
    public static void main(String[] args) {
        // Same graph as BFS
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < 4; i++) graph.add(new ArrayList<>());
        graph.get(0).addAll(Arrays.asList(1, 2));
        graph.get(1).addAll(Arrays.asList(0, 2, 3));
        graph.get(2).addAll(Arrays.asList(0, 1, 3));
        graph.get(3).addAll(Arrays.asList(1, 2));
        
        dfsWrapper(graph, 0);  // Start from node 0
    }
}
```
- output

```text
0 1 3 2
```
- (Order depends on neighbor order; e.g., dives 0→1→3, backtracks to 1→2.)
- **Edge Cases:**
- Disconnected Graph: Call DFS on each unvisited node.
- Single Node: Just prints it.
- Cycle: Visited prevents loops.