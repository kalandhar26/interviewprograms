# Open/Closed Principle (OCP)

## Scenario

- A bank supports multiple payment modes:
- UPI, Credit Card, Debit Card, Net Banking
- In the future, new payment modes (Wallet, Crypto, BNPL) will be added.

## Before OCP (Violation)

### Problematic Design

- Single class decides how payment is processed using **if-else / switch**.

```java
public class PaymentProcessorBeforeOCP {

    public void processPayment(String paymentType, double amount) {

        if (paymentType.equals("UPI")) {
            System.out.println("Processing UPI payment of ₹" + amount);

        } else if (paymentType.equals("CREDIT_CARD")) {
            System.out.println("Processing Credit Card payment of ₹" + amount);

        } else if (paymentType.equals("DEBIT_CARD")) {
            System.out.println("Processing Debit Card payment of ₹" + amount);

        } else if (paymentType.equals("NET_BANKING")) {
            System.out.println("Processing Net Banking payment of ₹" + amount);

        } else {
            throw new IllegalArgumentException("Unsupported payment type");
        }
    }
}
```

### Problems in Banking Systems

- Every new payment method requires modifying this class
- Risk of breaking existing payment flows
- Regression testing required for all payment types
- Violates OCP

### Reasons to change

- New payment method
- Change in logic of an existing method
- Regulatory changes per payment type

## After OCP ((Correct Design))

- We introduce abstraction.

### Step 1 : Payment Interface (Abstraction)

```java
public interface PaymentMethod {
    void pay(double amount);
}
```

### Step 2 : Concrete Implementations (Extensions)

1. UPI Payment

```java
public class UpiPayment implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Processing UPI payment of ₹" + amount);
    }
}

```

2. Credit Card Payment

```java
public class CreditCardPayment implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Processing Credit Card payment of ₹" + amount);
    }
}

```

3. Debit Card Payment

```java
public class DebitCardPayment implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Processing Debit Card payment of ₹" + amount);
    }
}
```

4. Net Banking Payment

```java
public class NetBankingPayment implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Processing Net Banking payment of ₹" + amount);
    }
}

```

### Step 3 : Payment Processor (Closed for Modification)

```java
public class PaymentProcessorAfterOCP {

    public void processPayment(PaymentMethod paymentMethod, double amount) {
        paymentMethod.pay(amount);
    }
}
```

- This class never changes, even if new payment modes are introduced.

### Step 4 : Adding a New Payment Type (No Modification)

- Wallet Payment (New Requirement)

```java
public class WalletPayment implements PaymentMethod {
    @Override
    public void pay(double amount) {
        System.out.println("Processing Wallet payment of ₹" + amount);
    }
}
```

- No change needed in PaymentProcessorAfterOCP.

### Step 5 : Client Code

```java
public class BankingApp {

    public static void main(String[] args) {

        PaymentProcessorAfterOCP processor = new PaymentProcessorAfterOCP();

        processor.processPayment(new UpiPayment(), 1000);
        processor.processPayment(new CreditCardPayment(), 2500);
        processor.processPayment(new WalletPayment(), 500);
    }
}
```

## Real-World Banking Benefits

✔ Safe extension of payment channels
✔ Regulatory changes isolated per payment type
✔ Cleaner microservice design
✔ Better unit testing
✔ Supports plug-and-play payment gateways