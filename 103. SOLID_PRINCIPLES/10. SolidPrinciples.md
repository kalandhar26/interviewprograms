## S – Single Responsibility Principle (SRP)

- A class should have only one reason to change.
- A class should have only one job or responsibility. If a class is handling multiple things (e.g., business logic and
  database operations), changes in one concern may affect the other.
- Promotes modularity.
- Makes code easier to understand, test, and maintain.

```java
public class ProductBeforeSRP {

    private String name;
    private double price;

    public ProductBeforeSRP(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public void saveProduct() {
        // Logic to save product to the database
        System.out.println("Product is saved to database");
    }

    public void generateInvoice() {
        // logic to generate invoice
        System.out.println("Invoice generated for product: " + name + " with rupees" + price);
    }
}
```

- We have a single class called 'ProductBeforeSRP' but it has multiple functionalities.
- Saving the Product to the database.
- Generate Invoices for the products.
- It has 3 responsibilities ( 1. It contains and maintains blueprint of ProductBeforeSRP class, 2. Connect to DB and
  Saving the Product to
  the database. 3. Generating the Invoices for the Products).
- Reasons to change: 1. **Tight Coupling** 2. **Hard to Test** 3. **Code complexity**.
- We will fix it now.

```java
public class ProductAfterSRP {

    private String name;
    private double price;

    public ProductAfterSRP(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}
```

```java
public class ProductRepository {

    public void saveProduct(ProductAfterSRP product) {
        // Logic to save product to the database
        System.out.println("Product is saved to database");
    }
}

```

```java
public class InvoiceGenerator {
    public void generateInvoice(ProductAfterSRP product) {
        // logic to generate invoice
        System.out.println("Invoice generated for product: " + product.getName() + " with rupees" + product.getPrice());
    }
}
```

```java
public class TestProduct {

    public static void main(String[] args) {
        ProductBeforeSRP bsrp = new ProductBeforeSRP("soap", 20.0);
        bsrp.saveProduct();
        bsrp.generateInvoice();


        ProductAfterSRP asrp = new ProductAfterSRP("soap1", 21.0);
        System.out.println(asrp.getName() + " " + asrp.getPrice());

        ProductRepository repo = new ProductRepository();
        repo.saveProduct(asrp);

        InvoiceGenerator invoice = new InvoiceGenerator();
        invoice.generateInvoice(asrp);

    }
}

```

- Now we have created separate class for each responsibility **(Single Responsibility)**.
- If i want to change anything related to db. then i can make changes to that particular class. which follows **loose
  coupling**.
- So it very **simple maintainable** code and **easy to test**.

---

## O – Open/Closed Principle (OCP)

- Software entities (classes, modules, functions) should be open for extension but closed for modification.
- You should be able to add new functionality without modifying existing code, usually by relying on abstraction (
  interfaces or base classes).
- Promotes extensibility without breaking existing functionality.
- Makes systems easier to maintain and scale. It helps to prevent bugs and regression by keeping tested code unchanged.

```java
public class NotificationBeforeOCP {

    public void sendNotification(String type) {
        if (type.equals("Email")) {
            System.out.println("Sending Email Notification");
        } else if (type.equals("SMS")) {
            System.out.println("Sending SMS Notification");
        } else if (type.equals("OTP")) {
            System.out.println("Sending OTP Notification");
        } else {
            System.out.println("Informing through call IVR");
        }
    }

    public void sendNotificationMessage(String type) {
        switch (type) {
            case "Email" -> System.out.println("Sending Email Notification");
            case "SMS" -> System.out.println("Sending SMS Notification");
            case "OTP" -> System.out.println("Sending OTP Notification");
            default -> System.out.println("Informing through call IVR");
        }
    }
}
```

- We have one class and one method. This works fine but in future if any new type of notification is introduced then we
  need to make changes to existing class method, by mistake if we make mistakes then the code which uses the class
  will be impacted. This is a not a good practice as again we should make sure existing code does not broke and need to
  perform regression testing on existing code. If we want to update logic for existing type then also it will impact the
  class.
- Instead of writing code like above, we should write using interfaces and abstract classes.

```java
public interface Notification {
    void send();
}
```

```java
public class NotificationViaEmail implements Notification {
    @Override
    public void send() {
        System.out.println();
    }
}
```

```java
public class NotificationViaSMS implements Notification {
    @Override
    public void send() {
        System.out.println("Sending SMS Notification");
    }
}
```

```java
public class NotificationViaOTP implements Notification {
    @Override
    public void send() {
        System.out.println(" Sending OTP Notification");
    }
}
```

```java
public class NotificationViaIVR implements Notification {
    @Override
    public void send() {
        System.out.println("Sending IVR notification");
    }
}
```

```java
public class NotificationAfterOCP {
    public void sendNotification(Notification notification) {
        notification.send();
    }
}
```

```java
public class TestNotification {

    public static void main(String[] args) {
        NotificationBeforeOCP bocp = new NotificationBeforeOCP();
        bocp.sendNotification("SMS");

        NotificationAfterOCP aocp = new NotificationAfterOCP();
        NotificationViaSMS notification = new NotificationViaSMS();
        aocp.sendNotification(notification);
    }
}
```

## L – Liskov Substitution Principle (LSP)

- Subtypes must be substitutable for their base types without altering the correctness of the program.
- A subclass should honor the contract defined by the base class. You should be able to replace a parent class with a
  subclass and the behavior should remain consistent.
- Prevents unexpected behavior.
- Ensures polymorphism works correctly and prevents incorrect assumptions when subclassing.
- If the parent class promises something. every child class must be able to deliver it. If they can't, do not put it in
  the parent- instead use interfaces.

```java
public class BirdBeforeLSP {
    public void fly() {
        System.out.println("Bird is flying");
    }
}
```

```java
// Penguin class is breaking the Liskov Principle. Whatever Parent Promised Child not able perform.
class Penguin extends BirdBeforeLSP {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly");
    }
}
```

```java
public class BirdWatcher {

    public void watchBirdFly(BirdBeforeLSP bird) {
        bird.fly();
    }

    public static void main(String[] args) {
        BirdWatcher watcher = new BirdWatcher();

        BirdBeforeLSP sparrow = new BirdBeforeLSP();
        watcher.watchBirdFly(sparrow); // Works fine

        Penguin penguin = new Penguin();
        watcher.watchBirdFly(penguin); // Throw an exception
    }
}
```

- The easiest way to fix what liskov principle is stating is you should be able to use interfaces for which you think
  all the child class will not be compatible.

```java
public abstract class BirdAfterLSP {
    public abstract void eat();
}
```

```java
public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}

```

```java
public class Sparrow extends BirdAfterLSP implements Flyable {
    @Override
    public void eat() {
        System.out.println("Sparrow can eat");
    }

    @Override
    public void fly() {
        System.out.println("Sparrow can fly");
    }
}

public class Penguin extends BirdAfterLSP implements Swimmable {

    @Override
    public void eat() {
        System.out.println("penguin can eat");
    }

    @Override
    public void swim() {
        System.out.println("penguin can swim");
    }
}
```

```java
public class BirdWatcher {

    public void watchBirdEat(BirdAfterLSP bird) {
        bird.eat();
    }

    public void watchBirdFly(Flyable bird) {
        bird.fly();
    }

    public void watchBirdSwim(Swimmable bird) {
        bird.swim();
    }

    public static void main(String[] args) {
        BirdWatcher watcher = new BirdWatcher();

        Sparrow sparrow = new Sparrow();
        watcher.watchBirdEat(sparrow);
        watcher.watchBirdFly(sparrow);
//        watcher.watchBirdSwim(sparrow); // This won't compile, which is correct

        Penguin penguin = new Penguin();
        watcher.watchBirdEat(penguin);
        watcher.watchBirdSwim(penguin);
//        watcher.watchBirdFly(penguin); // This won't compile, which is correct
    }
}
```

- The rule is any child class should work perfectly when used in place of its parent class. No exceptions, no surprises,
  No breaking code.
- The Goal is when yiu create a subclass, extends the parent behavior (make it better). do not replace it with something
  completely different that breaks expectations.
- If the code works with Bird class, then it should work just as well with any sparrow or eagle subclasses- but not with
  penguin that throws an errors when asked to fly.
- Do not promise what you cannot deliver. If your parent class sas "all birds can fly", then every bird subclass must
  actually be able to fly or you are breaking LSP.

## I – Interface Segregation Principle (ISP)

- Clients should not be forced to depend on interfaces they do not use.
- Split large interfaces into smaller, more specific interfaces so that implementing classes only need to define methods
  they actually use.
- Improves code clarity and cohesion.
- Reduces the chance of unused or dummy method implementations.

```java
public interface PaymentServiceBeforeISP {

    void authorizePayment();

    void capturePayment();

    void refundPayment();

    void voidPayment();

    void createSubscription();

    void cancelSubscription();

    void generateReport();

    void exportData();

    void sendNotification();
}
```

```java
public class SubscrptionService implements PaymentServiceBeforeISP {

    // Used Methods

    @Override
    public void createSubscription() {
        System.out.println("Subscription is created");
    }

    @Override
    public void cancelSubscription() {
        System.out.println("Subscription is cancelled");
    }

    @Override
    public void sendNotification() {
        System.out.println("Sent Notification for subscription or cancellation");
    }

    // UnUsed Methods

    @Override
    public void authorizePayment() {
        System.out.println("No need to use authorizePayment in SubscrptionService");
    }

    @Override
    public void capturePayment() {
        System.out.println("No need to use capturePayment in SubscrptionService");
    }

    @Override
    public void refundPayment() {
        System.out.println("No need to use refundPayment in SubscrptionService");
    }

    @Override
    public void voidPayment() {
        System.out.println("No need to use voidPayment in SubscrptionService");
    }


    @Override
    public void generateReport() {
        System.out.println("No need to use generateReport in SubscrptionService");
    }

    @Override
    public void exportData() {
        System.out.println("No need to use exportData in SubscrptionService");
    }
}
```

- After implementing Interface Seggregation Principle

```java
public interface Notifications {
    void sendNotification();
}

public interface SubscriptionOperations {
    void createSubscription();

    void cancelSubscription();
}

public interface PaymentOperations {
    void authorizePayment();

    void capturePayment();

    void refundPayment();

    void voidPayment();
}

public interface Reporting {
    void generateReport();

    void exportData();
}
```

```java
public class SubscriptionService implements SubscriptionOperations, Notifications {
    @Override
    public void sendNotification() {
        System.out.println("Notification sent");
    }

    @Override
    public void createSubscription() {
        System.out.println("subscription created");
    }

    @Override
    public void cancelSubscription() {
        System.out.println("subscription cancelled");
    }
}

```

```java
public class PaymentService implements PaymentOperations {
    @Override
    public void authorizePayment() {
        System.out.println("Payment Authorized");
    }

    @Override
    public void capturePayment() {
        System.out.println("Payment Captured");
    }

    @Override
    public void refundPayment() {
        System.out.println("Payment refunded");
    }

    @Override
    public void voidPayment() {
        System.out.println("Payment Voided");
    }

}
```

```java
public class ReportService implements Reporting, Notifications {

    @Override
    public void generateReport() {
        System.out.println("Report Generated");
    }

    @Override
    public void exportData() {
        System.out.println("Data Exported");
    }

    @Override
    public void sendNotification() {
        System.out.println("Reports are sent to Email");
    }
}
```

## D – Dependency Inversion Principle (DIP)

- High-level modules should not depend on low-level modules. Both should depend on abstractions.
- Abstractions should not depend on details. Details should depend on abstractions.
- Instead of tightly coupling classes to concrete implementations, depend on interfaces. This encourages loose coupling
  and makes your system more flexible and testable.
- Low-level classes: Handles basic operations such as file handling, database connections and network communication.
- High-Level classes: Manage complex business logic , coordinating and directing low level classes to perform specific
  tasks.

- **Steps to follow**
    1. Create abstraction or interfaces
    2. Implement Low Level Modules
    3. Implement High Level Modules depends on Abstraction

```java
// Low-level module (specific implementation)
public class StripePaymentGateway {
    public void processStripePayment(double amount) {
        System.out.println("Processing Stripe payment: $" + amount);
        // Stripe-specific API calls
    }

    public void refundStripePayment(String transactionId) {
        System.out.println("Refunding Stripe transaction: " + transactionId);
        // Stripe-specific refund logic
    }
}
```

```java
// Low-level module (specific implementation)
public class PayPalPaymentGateway {
    public void processPayPalPayment(double amount) {
        System.out.println("Processing PayPal payment: $" + amount);
        // PayPal-specific API calls
    }

    public void refundPayPalPayment(String transactionId) {
        System.out.println("Refunding PayPal transaction: " + transactionId);
        // PayPal-specific refund logic
    }
}
```

```java
// High-level module (business logic) - VIOLATES DIP
public class PaymentService {
    private final StripePaymentGateway stripeGateway;
    private final PayPalPaymentGateway paypalGateway;

    public PaymentService() {
        this.stripeGateway = new StripePaymentGateway(); // Tight coupling
        this.paypalGateway = new PayPalPaymentGateway(); // Tight coupling
    }

    public void processPayment(String gatewayType, double amount) {
        if ("stripe".equalsIgnoreCase(gatewayType)) {
            stripeGateway.processStripePayment(amount);
        } else if ("paypal".equalsIgnoreCase(gatewayType)) {
            paypalGateway.processPayPalPayment(amount);
        }
    }
}

/*
Tight coupling: PaymentService directly depends on concrete implementations
Hard to test: Can't easily mock payment gateways for testing
Hard to extend: Adding a new payment gateway requires modifying the high-level class
Violates Open/Closed Principle: Code isn't open for extension but closed for modification
 */

```

- Now we will see valid good example


```java
// Abstraction that both high-level and low-level modules depend on
public interface PaymentGateway {
    void processPayment(double amount);
    void refundPayment(String transactionId);
}
```
```java
// Abstraction that both high-level and low-level modules depend on
public interface PaymentProcessor {
    void processPayment(PaymentGateway gateway, double amount);
    void refundPayment(PaymentGateway gateway, String transactionId);
}
```

```java
public class PayPalGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing PayPal payment: $" + amount);
        // PayPal-specific implementation
    }

    @Override
    public void refundPayment(String transactionId) {
        System.out.println("Refunding PayPal transaction: " + transactionId);
        // PayPal-specific refund logic
    }
}
```

```java
// Low-level modules depend on abstraction (implement interface)
public class StripeGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing Stripe payment: $" + amount);
        // Stripe-specific implementation
    }

    @Override
    public void refundPayment(String transactionId) {
        System.out.println("Refunding Stripe transaction: " + transactionId);
        // Stripe-specific refund logic
    }
}

```

```java
public class BankTransferGateway implements PaymentGateway {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing bank transfer: $" + amount);
        // Bank transfer specific logic
    }

    @Override
    public void refundPayment(String transactionId) {
        System.out.println("Refunding bank transfer: " + transactionId);
        // Bank transfer refund logic
    }
}
```

```java
// High-level module depends on abstraction, not concrete implementations
public class PaymentService implements PaymentProcessor {

    @Override
    public void processPayment(PaymentGateway gateway, double amount) {
        // Business logic validation
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }

        // Logging, analytics, etc.
        System.out.println("Initiating payment processing...");

        // Delegate to the specific gateway
        /* The JVM uses runtime polymorphism to determine which actual implementation to execute:
        At compile time: The compiler only knows gateway is a PaymentGateway
        At runtime: The JVM looks at the actual object type and calls its specific implementation */
        gateway.processPayment(amount);

        // Post-processing logic
        System.out.println("Payment completed successfully");
    }

    @Override
    public void refundPayment(PaymentGateway gateway, String transactionId) {
        // Business logic for refunds
        System.out.println("Initiating refund process...");

        gateway.refundPayment(transactionId);

        System.out.println("Refund completed successfully");
    }
}
```

- Test Payment Service

```java
public class TestPaymentService {

    public static void main(String[] args) {
        PaymentService service = new PaymentService();
        PaymentGateway gateway = new StripeGateway();
        service.processPayment(gateway, 10.0);
        PaymentGateway gateway1 = new BankTransferGateway();
        service.processPayment(gateway1, 20.0);
        PaymentGateway gateway2 = new PayPalGateway();
        service.processPayment(gateway2, 30.0);
    }
}

```