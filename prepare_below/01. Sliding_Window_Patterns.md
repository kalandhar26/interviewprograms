## Sliding Window and Two Pointers
- In this topic we will see 4 kind of patterns
    1. Constant Window
    2. Longest SubArray or SubString. where some <Condition> [ Brute Force then Optimize] and expect ( maxLength, subArray)
        - We will start with Sliding window size of 1 and then we can increment.
        - We will have left and right pointers. Now we will have 2 concepts of window ( Expand and Shrink)
        - Expand will happen to right pointer and Shrink will happen to left pointer.
        - At any point the length of window will be right-left+1;
        - When the sum is greater then given target (sum <=k). Shrink the left by 1 place and check sum again if it 
        again sum greater than sum then again shrink the left by 1 place. and if sum satisfies then we go expand right.
        
```text
left=0,right=0; (constant)
sum=0; (based on requirement it changes)
maxLen=0; ( for all MaxLength or Longest it will be required)

while(right < arrayLength){ (constant)
    sum = sum + array[right]; (based on condition)
    // We can use While loop for sub Array [while(sum > k)] and if condition check for MaxLen [if(sum > k)]
    while(sum > k){ (constant) and inside condition is condition driven
    sum = sum - array[right]; // condition driven
    left = left+1; // condition driven
    }
    
    if(sum <= k){  // based on condition
        maxLen = max(maxLen, right-left+1); // constant
        // We can store left and right if SubArray is Asked
    }
    right = right+1; // constant
    }   
}
}

// If maxLength is asked
print(maxLen); (constant for Longest asked)

```
    3. Number of SubArrays where <condition> ( We will Pattern 2)
        1.find the number of sub arrays where sum <= K (X)
        2. find the number of sub arrays where sum <= K-1 (Y)
        3. Solution is X-Y

    4. Finding the Shortest/Minimum window where <condition>

        1. We take left and right and we move right and check if valid window.
        2. Once i got valid window and try to shrink the window and check again valid window.
        3. I will shirnk maximum times till valid window is satisfied.

# Pattern 1: Constant Window (Fixed Size)

```java
// Find maximum sum of any 3 consecutive numbers
public static int constantWindow(int[] arr, int k) {
    int left = 0;
    int currentSum = 0;
    int maxSum = 0;
    
    // First, fill the first window
    for (int right = 0; right < k; right++) {
        currentSum += arr[right];
    }
    
    maxSum = currentSum;
    
    // Slide the window through the array
    for (int right = k; right < arr.length; right++) {
        currentSum = currentSum + arr[right] - arr[left];
        maxSum = Math.max(maxSum, currentSum);
        left++;
    }
    
    return maxSum;
}

// Example usage
public static void main(String[] args) {
    int[] arr = {2, 1, 5, 1, 3, 2};
    int k = 3;
    System.out.println("Max sum of " + k + " consecutive: " + constantWindow(arr, k));
    // Output: 9 (from [5, 1, 3])
}
```

## Pattern 2: Longest Subarray/Substring

```java
// Find longest subarray with sum <= K
public static int longestSubarray(int[] arr, int K) {
    int left = 0;
    int currentSum = 0;
    int maxLength = 0;
    
    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];  // Expand window
        
        // Shrink window if condition breaks
        while (currentSum > K) {
            currentSum -= arr[left];
            left++;
        }
        
        // Update maximum length
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}

// Example usage
public static void main(String[] args) {
    int[] arr = {3, 1, 2, 1, 1, 1, 1};
    int K = 5;
    System.out.println("Longest subarray sum <= " + K + ": " + longestSubarray(arr, K));
    // Output: 4 (from [1, 1, 1, 1])
}
```

## Pattern 3: Number of (Count) Subarrays

```java
// Count subarrays with sum exactly equal to K
public static int countSubarrays(int[] arr, int K) {
    return countAtMost(arr, K) - countAtMost(arr, K - 1);
}

private static int countAtMost(int[] arr, int target) {
    int left = 0;
    int currentSum = 0;
    int count = 0;
    
    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];
        
        while (currentSum > target && left <= right) {
            currentSum -= arr[left];
            left++;
        }
        
        // All windows ending at 'right' are valid
        count += (right - left + 1);
    }
    
    return count;
}

// Example usage
public static void main(String[] args) {
    int[] arr = {1, 2, 3, 4, 1};
    int K = 6;
    System.out.println("Subarrays with sum exactly " + K + ": " + countSubarrays(arr, K));
    // Output: 2 ([2, 3, 1] and [3, 4, -1])
}
```

## Pattern 4: Shortest/Minimum Window

```java
// Find shortest subarray with sum >= K
public static int shortestSubarray(int[] arr, int K) {
    int left = 0;
    int currentSum = 0;
    int minLength = Integer.MAX_VALUE;

    for (int right = 0; right < arr.length; right++) {
        currentSum += arr[right];  // Expand

        // Try to shrink while condition is still satisfied
        while (currentSum >= K) {
            minLength = Math.min(minLength, right - left + 1);
            currentSum -= arr[left];
            left++;
        }
    }

    return minLength != Integer.MAX_VALUE ? minLength : 0;
}

// Example usage
public static void main(String[] args) {
    int[] arr = {2, 1, 5, 2, 3, 2};
    int K = 7;
    System.out.println("Shortest subarray sum >= " + K + ": " + shortestSubarray(arr, K));
    // Output: 2 (from [5, 2])
}
```