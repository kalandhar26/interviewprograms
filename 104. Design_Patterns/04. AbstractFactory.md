## Abstract Factory Pattern

**What it does:** Creates families of related objects (e.g., all UI elements for Windows/Mac).
**Real-life example:** Buying a furniture set (all pieces match the same style – modern/classic).
**defination** The Abstract Factory pattern provides an interface to create families of related or dependent objects
without specifying their concrete classes.
It’s considered a factory of factories and is part of creational design patterns.
This is useful when your system needs to be platform-independent or theme-based, where multiple families of related
products need to be created together.

- Provide an interface for creating families of related objects (GUI toolkit, DB drivers) without specifying their
  concrete classes.
## PseudoCode

```text
1. create multiple product interfaces.
2. create concrete implementations for each product.
3. create a abstract factory interface that declares method for creating each product.
4. create concrete factories for each family.
5. client code uses the factory, not new. so it can works with any family.
```

```java
// Step 1: Create multiple product interfaces
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

// Step 2: Create concrete implementations for each product
class WinButton implements Button {
    public void paint() {
        System.out.println("WinButton");
    }
}

class MacButton implements Button {
    public void paint() {
        System.out.println("MacButton");
    }
}

class WinCheckbox implements Checkbox {
    public void paint() {
        System.out.println("WinCheckbox");
    }
}

class MacCheckbox implements Checkbox {
    public void paint() {
        System.out.println("MacCheckbox");
    }
}

// Step 3: Create an abstract factory interface 
//         that declares methods for creating each product
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Step 4: Create concrete factories for each family
class WinFactory implements GUIFactory {
    public Button createButton() {
        return new WinButton();
    }
    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Step 5: Client code uses the factory, not `new` directly
public class AbstractFactoryStepwiseDemo {
    public static void main(String[] args) {
        // Pick factory based on OS
        GUIFactory factory = System.getProperty("os.name").startsWith("Mac")
                ? new MacFactory()
                : new WinFactory();

        Button btn = factory.createButton();
        Checkbox chk = factory.createCheckbox();

        btn.paint();   // prints MacButton or WinButton
        chk.paint();   // prints MacCheckbox or WinCheckbox
    }
}
```
Output:
```text
WinButton
WinCheckbox
```