## Factory Pattern

- Factory design pattern creates objects without exposing the creation logic.
- You ask for a "vehicle", and it gives you a car or bike.
- The Factory Method pattern defines an interface for creating an object but lets subclasses alter the type
  of objects that will be created.
  This is also a creational pattern that promotes loose coupling by delegating the instantiation logic to child classes.
  It is often used when the client doesn’t know exactly which type to instantiate.

- Encapsulate object creation logic behind a static method so client code never uses new.

## Pseudo Code

```text
1. Create a common interface or abstract class.
2. Create a concrete class/classes that implements the common interface. 
3. Create a factory class with a method. Inside a method check the type and return the current Object type with new keyword.
4. The Client code calls the Factory method. (not new). Client does not know which concrete class is created.
```

```text
1. Define a Product Interface (or Abstract Class)
   - This declares the operations common to all product types.

2. Create Concrete Product Classes
   - Implement the Product interface.
   - Each class represents a specific type of product.

3. Define a Factory Interface or Abstract Factory Class
   - Declare a factory method for creating products.
   - The method returns a Product type.

4. Implement Concrete Factories
   - Each concrete factory implements the factory method.
   - It creates and returns instances of different concrete products.

5. Client Code Calls Factory
   - Client requests a product by invoking the factory's method.
   - The client deals with products through the common interface.
   - Client does NOT instantiate product classes directly.

```

## Scenario:

- A Bank supports multiple account types: Savings Account, Current Account, Salary Account, Loan Account
- Each account has: Different rules, Different limits, Different interest logic

## Without Factory Design Pattern (Bad Design)

```java
class SavingsAccount {
    public void openAccount() {
        System.out.println("Savings Account opened");
    }
}

class CurrentAccount {
    public void openAccount() {
        System.out.println("Current Account opened");
    }
}

class SalaryAccount {
    public void openAccount() {
        System.out.println("Salary Account opened");
    }
}

public class BankAccountService {

    public static void main(String[] args) {

        String type = "SAVINGS"; // Input from UI / API

        if (type.equals("SAVINGS")) {
            SavingsAccount acc = new SavingsAccount();
            acc.openAccount();

        } else if (type.equals("CURRENT")) {
            CurrentAccount acc = new CurrentAccount();
            acc.openAccount();

        } else if (type.equals("SALARY")) {
            SalaryAccount acc = new SalaryAccount();
            acc.openAccount();

        } else {
            throw new IllegalArgumentException("Invalid account type");
        }
    }
}
```

## With Factory (Good Design)

- Client Says "Give me an Bank Account", Factory decides which type of account to create.

## Example 1:

### Step 1: Create a Common Interface (Product)

```java
interface BankAccount {
    void openAccount();
}
```

- This is the rule that all accounts must follow.

### Step 2: Create Concrete Classes that Implement the Common Interface

```java
class SavingsAccount implements BankAccount {
    public void openAccount() {
        System.out.println("Savings Account opened");
    }
}

class CurrentAccount implements BankAccount {
    public void openAccount() {
        System.out.println("Current Account opened");
    }
}

class SalaryAccount implements BankAccount {
    public void openAccount() {
        System.out.println("Salary Account opened");
    }
}
```

- These classes follow the common interface and implement the required methods.
- Each account has its own behavior

### Step 3: Factory Interface

```java
interface AccountFactory {
    BankAccount createAccount(String type);
}
```

- Factory promises i will provide Bank Account.

### Step 4: Concrete Factory Implementation

```java
class BankAccountFactory implements AccountFactory {

    @Override
    public BankAccount createAccount(String type) {

        if (type == null)
            throw new IllegalArgumentException("Account type cannot be null");

        switch (type.toUpperCase()) {
            case "SAVINGS":
                return new SavingsAccount();
            case "CURRENT":
                return new CurrentAccount();
            case "SALARY":
                return new SalaryAccount();
            default:
                throw new IllegalArgumentException("Invalid account type");
        }
    }
}

```

- All object creation logic is hidden here

### Step 5: Client Code (Bank App)

```java
public class BankFactoryDemo {

    public static void main(String[] args) {

        AccountFactory factory = new BankAccountFactory();

        BankAccount acc1 = factory.createAccount("SAVINGS");
        acc1.openAccount();

        BankAccount acc2 = factory.createAccount("CURRENT");
        acc2.openAccount();
    }
}
```

- output

```text
Savings Account opened
Current Account opened
```

## SOLID Principles Followed

✔ SRP – Creation logic separated
✔ OCP – Add new account without touching client
✔ DIP – Client depends on interface

----------------------------

## Example 2 :

```java
// Step 1: Define a Product Interface (or Abstract Class)
interface Vehicle {
    void drive();
}

// Step 2: Create Concrete Product Classes
class Car implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Car driving");
    }
}

class Bike implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Bike driving");
    }
}

// Step 3: Define a Factory Interface
interface VehicleFactory {
    Vehicle createVehicle(String type);
}

// Step 4: Implement Concrete Factory
class SimpleVehicleFactory implements VehicleFactory {
    @Override
    public Vehicle createVehicle(String type) {
        if (type == null) {
            throw new IllegalArgumentException("Type cannot be null");
        }
        switch (type.toLowerCase()) {
            case "car":
                return new Car();
            case "bike":
                return new Bike();
            default:
                throw new IllegalArgumentException("Unknown vehicle: " + type);
        }
    }
}

// Step 5: Client Code Calls Factory
public class FactoryStepwiseDemo {
    public static void main(String[] args) {
        VehicleFactory factory = new SimpleVehicleFactory();

        Vehicle v1 = factory.createVehicle("car");
        v1.drive();   // prints: Car driving

        Vehicle v2 = factory.createVehicle("bike");
        v2.drive();   // prints: Bike driving

        // Uncomment to see the error for an unknown type:
        // Vehicle v3 = factory.createVehicle("truck");
    }
}

```

Output:

```text
Car driving
Bike driving
```

-----------------------------------

## Example 3:

```java
interface Notification {
    void send();
}

class SMSNotification implements Notification {
    public void send() {
        System.out.println("SMS sent");
    }
}

class EmailNotification implements Notification {
    public void send() {
        System.out.println("Email sent");
    }
}

class NotificationFactory {
    public static Notification getNotification(String type) {
        if (type.equalsIgnoreCase("SMS"))
            return new SMSNotification();
        else
            return new EmailNotification();
    }
}
```

-----------------------------------

## Real Banking Use-Cases for Factory

✔ Account creation
✔ Loan type selection (Home / Car / Personal)
✔ Interest calculation strategies
✔ Notification types (SMS / Email / Push)
✔ Payment modes (UPI / Card / NetBanking)