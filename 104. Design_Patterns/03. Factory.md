## Factory Pattern

**What it does:** Creates objects without exposing the creation logic. You ask for a "vehicle", and it gives you a car
or bike.
**Real-life example:** A pizza shop where you just say "I want a pizza" (factory decides if it's veg or non-veg).
**defination** The Factory Method pattern defines an interface for creating an object but lets subclasses alter the type
of objects that will be created.
This is also a creational pattern that promotes loose coupling by delegating the instantiation logic to child classes.
It is often used when the client doesnâ€™t know exactly which type to instantiate.

- Encapsulate object creation logic behind a static method so client code never uses new.

## Pseudo Code

```text
1. Create a common interface or abstract class.
2. Create a concrete class/classes that implements the common interface. 
3. Create a factory class with a method. Inside a method check the type and return the current Object type with new keyword.
4. The Client code calls the Factory method. (not new). Client does not know which concrete class is created.
```

```text
1. Define a Product Interface (or Abstract Class)
   - This declares the operations common to all product types.

2. Create Concrete Product Classes
   - Implement the Product interface.
   - Each class represents a specific type of product.

3. Define a Factory Interface or Abstract Factory Class
   - Declare a factory method for creating products.
   - The method returns a Product type.

4. Implement Concrete Factories
   - Each concrete factory implements the factory method.
   - It creates and returns instances of different concrete products.

5. Client Code Calls Factory
   - Client requests a product by invoking the factory's method.
   - The client deals with products through the common interface.
   - Client does NOT instantiate product classes directly.

```

## Challenges

- **Challenge 1**: Tight Coupling in Object Creation.

```java
class Factory {
    public static void main(String[] args) {
        if (type.equals("CIRCLE")) {
            return new Circle();
        } else if (type.equals("RECTANGLE")) {
            return new Rectangle();
        }
    }
}
```

- **Issues**:
    1. Hard Coded Object Creation.
    2. Violates Open/Closed Principle.
    3. Difficult to add new types.
    4. Client code knows about concrete classes.

- **challenge 2**: Scalability Nightmare

- When building a notification system.
    1. Adding new notification types requires code changes everywhere.
    2. Conditional logic scattered across the codebase.
    3. Testing becomes complex with multiple branches.
    4. Maintenance headaches as system grows.

- **challenge 3**: Violation of SOLID Principles
  - Single Responsibility: Object creation is mixed with business logic.
  - Open / Closed: Not Open for extension, requires modification.
  - Dependency Inversion : Depends on concrete classes, not abstractions.


```java
// Step 1: Define a Product Interface (or Abstract Class)
interface Vehicle {
    void drive();
}

// Step 2: Create Concrete Product Classes
class Car implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Car driving");
    }
}

class Bike implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Bike driving");
    }
}

// Step 3: Define a Factory Interface
interface VehicleFactory {
    Vehicle createVehicle(String type);
}

// Step 4: Implement Concrete Factory
class SimpleVehicleFactory implements VehicleFactory {
    @Override
    public Vehicle createVehicle(String type) {
        if (type == null) {
            throw new IllegalArgumentException("Type cannot be null");
        }
        switch (type.toLowerCase()) {
            case "car":
                return new Car();
            case "bike":
                return new Bike();
            default:
                throw new IllegalArgumentException("Unknown vehicle: " + type);
        }
    }
}

// Step 5: Client Code Calls Factory
public class FactoryStepwiseDemo {
    public static void main(String[] args) {
        VehicleFactory factory = new SimpleVehicleFactory();

        Vehicle v1 = factory.createVehicle("car");
        v1.drive();   // prints: Car driving

        Vehicle v2 = factory.createVehicle("bike");
        v2.drive();   // prints: Bike driving

        // Uncomment to see the error for an unknown type:
        // Vehicle v3 = factory.createVehicle("truck");
    }
}

```
Output:
```text
Car driving
Bike driving
```