## Builder Pattern

- Builder design pattern constructs complex objects step by step (like customizing a computer).
- It allows you to produce different types and representations of an object using the same construction process.
- Construct complex immutable objects step-by-step, separating construction from representation. Eliminates telescoping
  constructors.
- Builder Pattern is used in banking systems to construct complex immutable objects like transaction requests or loan
  applications step-by-step, avoiding constructor overloading.

## PseudoCode (Builder)

```text
1. create a class with many fields.
2. Make the constructor private.
3. Create a nested Builder class with the same fields.
4. In the Builder, create methods to set each field (returning this for chaining).
5. provide a build() method in builder to return the final object (original class object).
6. client code uses the builder to create objects in a readable way.
```

## Scenario

- Bank creates a Transaction Request.
- A transaction may have: From Account (mandatory), To Account (mandatory), Amount (mandatory), Currency (optional),
  Remarks (optional), Scheduled Date (optional), International flag (optional), Charges (optional)
- Too many constructors = nightmare (telescoping constructor)

## Without Builder Pattern (Bad)

```java
import java.time.LocalDate;

class Transaction {

    private String fromAccount;
    private String toAccount;
    private double amount;
    private String remarks;
    private String currency;
    private LocalDate scheduleDate;

    // 1️⃣ Mandatory fields only
    public Transaction(String fromAccount, String toAccount, double amount) {
        this.fromAccount = fromAccount;
        this.toAccount = toAccount;
        this.amount = amount;
    }

    // 2️⃣ Mandatory + remarks
    public Transaction(String fromAccount, String toAccount, double amount, String remarks) {
        this(fromAccount, toAccount, amount);
        this.remarks = remarks;
    }

    // 3️⃣ Mandatory + remarks + currency
    public Transaction(String fromAccount, String toAccount, double amount,
                       String remarks, String currency) {
        this(fromAccount, toAccount, amount, remarks);
        this.currency = currency;
    }

    // 4️⃣ Mandatory + remarks + currency + schedule
    public Transaction(String fromAccount, String toAccount, double amount,
                       String remarks, String currency, LocalDate scheduleDate) {
        this(fromAccount, toAccount, amount, remarks, currency);
        this.scheduleDate = scheduleDate;
    }

    public void printTransaction() {
        System.out.println(
                "From: " + fromAccount +
                        ", To: " + toAccount +
                        ", Amount: " + amount +
                        ", Remarks: " + remarks +
                        ", Currency: " + currency +
                        ", Schedule: " + scheduleDate
        );
    }
}

```

## With Builder Pattern (Good)

### Step 1: Create a Class with Many Fields

```java
final class BankTransaction {

    // Step 1: Create a Class with Many Fields
    private final String fromAccount;
    private final String toAccount;
    private final double amount;

    private final String currency;
    private final String remarks;
    private final boolean international;

    // Step 2: Make Constructor Private (No one can do new BankTransaction() directly.)
    private BankTransaction(Builder b) {
        this.fromAccount = b.fromAccount;
        this.toAccount = b.toAccount;
        this.amount = b.amount;
        this.currency = b.currency;
        this.remarks = b.remarks;
        this.international = b.international;
    }

    // Step 3: Create Nested Builder Class
    public static class Builder {

        // Mandatory fields
        private final String fromAccount;
        private final String toAccount;
        private final double amount;

        // Optional fields
        private String currency = "INR";
        private String remarks = "";
        private boolean international = false;

        // Step 4: Builder Constructor (Mandatory Fields)
        public Builder(String from, String to, double amt) {
            this.fromAccount = from;
            this.toAccount = to;
            this.amount = amt;
        }

        // Step 5: Builder Setter Methods (Optional) (Each returns this → method chaining)
        public Builder currency(String c) {
            this.currency = c;
            return this;
        }

        public Builder remarks(String r) {
            this.remarks = r;
            return this;
        }

        public Builder international(boolean flag) {
            this.international = flag;
            return this;
        }

        // Step 6: build() Method
        public BankTransaction build() {
            return new BankTransaction(this);
        }

    }
}

// Step 7: Client Code (Bank App)
public class BankingBuilderDemo {

    public static void main(String[] args) {

        BankTransaction txn =
                new BankTransaction.Builder("ACC1001", "ACC2002", 50000)
                        .currency("USD")
                        .remarks("Education Fees")
                        .international(true)
                        .build();

        System.out.println("Transaction created successfully");
    }
}
```

- output

```text
Transaction created successfully
```

----

## Example 2

```java
final class House {

    private final int rooms;
    private final boolean garage;
    private final String material;

    private House(Builder b) {
        this.rooms = b.rooms;
        this.garage = b.garage;
        this.material = b.material;
    }

    public static class Builder {
        private final int rooms;
        private boolean garage = false;
        private String material = "wood";

        // constructor enforces mandatory field
        public Builder(int rooms) {
            this.rooms = rooms;
        }

        // Below methods are optional fields
        public Builder garage(boolean g) {
            this.garage = g;
            return this;
        }

        public Builder material(String m) {
            this.material = m;
            return this;
        }

        public House build() {
            return new House(this);
        }
    }
}

class BuilderDemo {
    static void run() {
        House h = new House.Builder(3)
                .garage(true)
                .material("concrete")
                .build();
        System.out.println("House built: " + h);
    }
}
```

1️⃣ Bank defines Transaction object
2️⃣ Constructor is hidden
3️⃣ Builder collects details step-by-step
4️⃣ Mandatory details are forced
5️⃣ Optional details are flexible
6️⃣ Final object is created only once

- Factory chooses WHAT to create
- Builder decides HOW to build it

## Real Banking Use-Cases of Builder Pattern

✔ Transaction requests
✔ Loan application forms
✔ Account opening requests
✔ KYC data creation
✔ API request/response objects
✔ Payment instruction messages