## Adapter Pattern

- Adapter Pattern is a structural design pattern that allows two incompatible interfaces to work together.
- It converts the interface of an existing class into another interface that the client expects, without changing the
  existing class.
- It falls under structural design patterns because it is concerned with class and object composition.
- Convert the interface of an existing class into another interface clients expect. Allows classes to work together that
  otherwise couldn’t.

## PseudoCode

```text
1. Create a Target interface (the interface that client excepts)
2. Have an existing class (Adaptee) with a different/incompatible method.
3. Create an adapter class that implements target interface and internally call the Adaptee method.
4. Client code uses the target interface, but the adapter translates the call to the Adaptee. 
```

## Scenario

- A Banking System internally expects JSON-based payment requests But an external payment gateway sends data in XML
  format.
- Interfaces are incompatible: Bank expects → processPayment(JsonRequest), Gateway provides → makePayment(XmlRequest)##
  Example 1

## Without Adapter

- Bank code must change ❌
- Gateway code must change ❌
- High risk & high cost ❌

## With Adapter Pattern

- Create an Adapter that converts XML → JSON
- Bank system stays unchanged
- Gateway stays unchanged

## Example 1

### Step 1: Target Interface (What Bank Expects)

```java
interface BankPaymentService {
    void processPayment(String jsonRequest);
}
```

- Bank system understands JSON only

### Step 2: Adaptee (What Gateway Provides)

```java
class ExternalPaymentGateway {

    public void makePayment(String xmlRequest) {
        System.out.println("Processing payment via external gateway using XML");
    }
}
```

- Gateway understands XML only

### Step 3: Adapter Class (Bridge)

```java
class PaymentGatewayAdapter implements BankPaymentService {

    private final ExternalPaymentGateway gateway = new ExternalPaymentGateway();

    @Override
    public void processPayment(String jsonRequest) {

        // Convert JSON → XML (simplified)
        String xmlRequest = "<payment>" + jsonRequest + "</payment>";

        gateway.makePayment(xmlRequest);
    }
}

```

- Adapter: Implements Bank interface, Internally calls Gateway method.

### Step 4: Client Code (Bank App)

```java
public class AdapterBankingDemo {

    public static void main(String[] args) {

        BankPaymentService paymentService = new PaymentGatewayAdapter();

        paymentService.processPayment("{amount:10000, from:ACC1, to:ACC2}");
    }
}
```

- output

```text
Processing payment via external gateway using XML
```

------------

## Example 2

```java
// Target interface
interface BasicMediaPlayer {
    void play(String filename);
}

// Target interface
interface AdvancedMediaPlayer {
    void playVlc(String f);

    void playMp4(String f);
}

// Adaptee class
class VlcPlayer implements AdvancedMediaPlayer {
    public void playVlc(String f) {
        System.out.println("Playing vlc " + f);
    }

    public void playMp4(String f) {
        System.out.println("Playing Mp4 " + f);
    }
}


// Adapter class
class MediaAdapter implements BasicMediaPlayer {
    private final AdvancedMediaPlayer adv = new VlcPlayer();

    public void play(String filename) {
        if (filename.endsWith(".vlc"))
            adv.playVlc(filename);
    }
}

// Client code
class AdapterDemo {
    static void run() {
        BasicMediaPlayer player = new MediaAdapter();
        player.play("movie.vlc");
    }
}
```

## Real Banking Use-Cases for Adapter Pattern

✔ Core Banking ↔ Payment Gateway
✔ ISO-20022 XML ↔ Internal JSON
✔ Old legacy system ↔ New microservice
✔ Card network (Visa/Master) adapters
✔ SWIFT ↔ Internal transaction format

- Factory creates
- Builder builds
- Adapter translates