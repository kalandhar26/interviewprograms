## Observer Pattern

- When one object (Subject) changes state, it should automatically notify all dependent objects (Observers).

## PseudoCode

```text
1. Create a Subject interface (methods to attach, detach and notify observers)
2. Create a concrete Subject class (Stores state and a list of Observers).
3. Create an Observer interface - defines an update() method.
4. Create an Concrete Observer classes - react to changes in Subject.
5. Client code - subject adds observers, changes state and observers get notified automatically.
```

## Scenario

- Transaction Alert System
- When a bank account transaction happens, multiple systems must be notified automatically, such as: SMS Alert Service,
  Email Notification Service, Fraud Detection System, and Account Statement Service.
- The Account does not know how these services work â€” it only notifies them. This is exactly where Observer Pattern
  fits.
- Whenever an account balance changes, all subscribed systems must be notified immediately without modifying account logic.

## Example 1

```java
// Observer
interface BankObserver {
    void update(String message);
}

// Concrete Observers
class SmsAlertService implements BankObserver {
    public void update(String message) {
        System.out.println("SMS Alert: " + message);
    }
}

class EmailAlertService implements BankObserver {
    public void update(String message) {
        System.out.println("Email Alert: " + message);
    }
}

class FraudDetectionService implements BankObserver {
    public void update(String message) {
        System.out.println("Fraud Check Triggered for: " + message);
    }
}

// Subject
class BankAccount {
    private final List<BankObserver> observers = new ArrayList<>();
    private double balance;

    public void addObserver(BankObserver observer) {
        observers.add(observer);
    }

    public void removeObserver(BankObserver observer) {
        observers.remove(observer);
    }

    private void notifyObservers(String message) {
        for (BankObserver observer : observers) {
            observer.update(message);
        }
    }

    public void deposit(double amount) {
        balance += amount;
        notifyObservers("Amount credited: " + amount + ", Balance: " + balance);
    }

    public void withdraw(double amount) {
        balance -= amount;
        notifyObservers("Amount debited: " + amount + ", Balance: " + balance);
    }
}

// Client Code

public class BankingObserverDemo {
    public static void main(String[] args) {

        BankAccount account = new BankAccount();

        account.addObserver(new SmsAlertService());
        account.addObserver(new EmailAlertService());
        account.addObserver(new FraudDetectionService());

        account.deposit(5000);
        account.withdraw(3000);
    }
}

```
- output

```text
SMS Alert: Amount credited: 5000, Balance: 5000
Email Alert: Amount credited: 5000, Balance: 5000
Fraud Check Triggered for: Amount credited: 5000, Balance: 5000

SMS Alert: Amount debited: 3000, Balance: 2000
Email Alert: Amount debited: 3000, Balance: 2000
Fraud Check Triggered for: Amount debited: 3000, Balance: 2000
```
===============================

## Example 2

```java
// Step 1: Create a Subject interface
interface Subject {
    void attach(Observer o);

    void detach(Observer o);

    void notifyObservers();
}

// Step 2: Create a Concrete Subject class
class ConcreteSubject implements Subject {
    private final List<Observer> observers = new ArrayList<>();
    private String state;

    public void setState(String state) {
        this.state = state;
        notifyObservers(); // whenever state changes, notify all
    }

    public String getState() {
        return state;
    }

    @Override
    public void attach(Observer o) {
        observers.add(o);
    }

    @Override
    public void detach(Observer o) {
        observers.remove(o);
    }

    @Override
    public void notifyObservers() {
        for (Observer o : observers) {
            o.update(state);
        }
    }
}

// Step 3: Create an Observer interface
interface Observer {
    void update(String newState);
}

// Step 4: Create Concrete Observer classes
class ConcreteObserverA implements Observer {
    @Override
    public void update(String newState) {
        System.out.println("Observer A received update: " + newState);
    }
}

class ConcreteObserverB implements Observer {
    @Override
    public void update(String newState) {
        System.out.println("Observer B received update: " + newState);
    }
}

// Step 5: Client code
public class ObserverPatternDemo {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();

        Observer obsA = new ConcreteObserverA();
        Observer obsB = new ConcreteObserverB();

        subject.attach(obsA);
        subject.attach(obsB);

        subject.setState("State 1"); // both observers notified
        subject.setState("State 2"); // both observers notified
    }
}

```
