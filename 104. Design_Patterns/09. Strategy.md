## Strategy Pattern

**What it does:** Lets you switch algorithms at runtime (like choosing payment methods).
**Real-life example:** Selecting a route on Google Maps (driving/walking/biking).
**defination** The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them
interchangeable. It allows the algorithm to vary independently of clients that use it.

This is a behavioral design pattern that promotes flexibility and extensibility, often used when you have multiple ways
to perform an operation like payment, sorting, or compression.

- Define a family of interchangeable algorithms and make them swappable at runtime.

## PseudoCode:

```text
1. Create a strategy interface (defines a common method)
2. Create a concrete Strategy classes (different implementations of the algorithm)
3. Create a context class (holds data and uses a Strategy Object)
4. The Context delegates the work to the chosen Strategy.
5. Client chooses which strategy to use at runtime. This makes algorithms interchangeable and swappable at runtime 
without changing the client code.
```

```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardStrategy implements PaymentStrategy {
    public void pay(int amt) {
        System.out.println("Paid " + amt + " with credit card");
    }
}

class PayPalStrategy implements PaymentStrategy {
    public void pay(int amt) {
        System.out.println("Paid " + amt + " with PayPal");
    }
}

class ShoppingCart {
    private final List<Integer> prices = new ArrayList<>();

    public void add(int p) {
        prices.add(p);
    }

    public void pay(PaymentStrategy strategy) {
        int total = prices.stream().mapToInt(Integer::intValue).sum();
        strategy.pay(total);
    }
}

class StrategyDemo {
    static void run() {
        ShoppingCart cart = new ShoppingCart();
        cart.add(100);
        cart.add(50);
        cart.pay(new PayPalStrategy());
    }
}
```

- **Example 2**

```java
// Step 1: Create a strategy interface
interface Strategy {
    void execute();
}

// Step 2: Create concrete strategy classes
class StrategyA implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy A");
    }
}

class StrategyB implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy B");
    }
}

// Step 3: Create a context class
class Context {
    private Strategy strategy;

    // Set the strategy at runtime
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    // Step 4: Context delegates work to chosen strategy
    public void doWork() {
        if (strategy == null) {
            System.out.println("No strategy selected");
        } else {
            strategy.execute();
        }
    }
}

// Step 5: Client chooses strategy at runtime
public class StrategyPatternSimpleDemo {
    public static void main(String[] args) {
        Context context = new Context();

        context.setStrategy(new StrategyA());  // choose Strategy A
        context.doWork();

        context.setStrategy(new StrategyB());  // switch to Strategy B
        context.doWork();
    }
}
```
Output:
```text
Executing Strategy A
Executing Strategy B

```