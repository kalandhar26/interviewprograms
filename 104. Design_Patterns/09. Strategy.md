## Strategy Pattern

**What it does:** Lets you switch algorithms at runtime (like choosing payment methods).
**Real-life example:** Selecting a route on Google Maps (driving/walking/biking).
**defination** The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them
interchangeable. It allows the algorithm to vary independently of clients that use it.

This is a behavioral design pattern that promotes flexibility and extensibility, often used when you have multiple ways
to perform an operation like payment, sorting, or compression.

- Define a family of interchangeable algorithms and make them swappable at runtime.

## PseudoCode:

```text
1. Create a strategy interface (defines a common method)
2. Create a concrete Strategy classes (different implementations of the algorithm)
3. Create a context class (holds data and uses a Strategy Object)
4. The Context delegates the work to the chosen Strategy.
5. Client chooses which strategy to use at runtime. This makes algorithms interchangeable and swappable at runtime 
without changing the client code.
```

```java
// Step 1: Create Strategy Interface
interface PaymentStrategy {
    void pay(double amount);
}

// Step 2: Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Credit Card.");
    }
}

class PayPalPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using PayPal.");
    }
}

class BankTransferPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Bank Transfer.");
    }
}

// Step 3: Context Class
class PaymentContext {
    private PaymentStrategy strategy;

    // Set strategy at runtime
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void payAmount(double amount) {
        if (strategy == null) {
            System.out.println("No payment method selected.");
        } else {
            strategy.pay(amount);
        }
    }
}

// Step 4: Client
public class StrategyPatternDemo {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext();

        // Use Credit Card
        context.setPaymentStrategy(new CreditCardPayment());
        context.payAmount(100.0);

        // Use PayPal
        context.setPaymentStrategy(new PayPalPayment());
        context.payAmount(200.0);

        // Use Bank Transfer
        context.setPaymentStrategy(new BankTransferPayment());
        context.payAmount(300.0);
    }
}
```
Output:
```text
Paid 100.0 using Credit Card.
Paid 200.0 using PayPal.
Paid 300.0 using Bank Transfer.

```

- **Example 2**

```java
// Step 1: Create a strategy interface
interface Strategy {
    void execute();
}

// Step 2: Create concrete strategy classes
class StrategyA implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy A");
    }
}

class StrategyB implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy B");
    }
}

// Step 3: Create a context class
class Context {
    private Strategy strategy;

    // Set the strategy at runtime
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    // Step 4: Context delegates work to chosen strategy
    public void doWork() {
        if (strategy == null) {
            System.out.println("No strategy selected");
        } else {
            strategy.execute();
        }
    }
}

// Step 5: Client chooses strategy at runtime
public class StrategyPatternSimpleDemo {
    public static void main(String[] args) {
        Context context = new Context();

        context.setStrategy(new StrategyA());  // choose Strategy A
        context.doWork();

        context.setStrategy(new StrategyB());  // switch to Strategy B
        context.doWork();
    }
}
```
Output:
```text
Executing Strategy A
Executing Strategy B
```