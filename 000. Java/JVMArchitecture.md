# JVM Architecture Overview

- The JVM architecture can be divided into several key components, each responsible for specific tasks in the process of
  executing a Java program. These components include the Class Loader Subsystem, Bytecode Verifier, Memory Areas,
  Execution Engine, and other supporting mechanisms.

## Java Source Code and Compilation

- Programmer Code: The process begins with the programmer writing Java source code (.java files) stored in a source
  folder.
- Java Compiler (javac): The Java Compiler compiles the .java files into bytecode (.class files). Bytecode is
  platform-independent, meaning it can run on any system with a JVM.
- Bytecode: This is an intermediate representation of the program, which the JVM understands and executes.

## Class Loader Subsystem

- The Class Loader Subsystem is responsible for loading, linking, and initializing the .class files (bytecode) into the
  JVM's memory. It performs three main activities: Loading, Linking, and Initialization.

### Loading

- The loading phase involves reading the .class files and creating corresponding class structures in memory. The JVM
  uses
  three types of class loaders, each with specific responsibilities:

#### Bootstrap Class Loader:

- Loads core Java API classes from the rt.jar file (part of the Java Runtime Environment, located in jre/lib).
- Written in native code (C/C++), not Java.
- Has the highest precedence among class loaders.

#### Extension Class Loader:

- Loads classes from the extension directories (jre/lib/ext or other directories specified by the java.ext.dirs
  property).
- Responsible for loading optional packages or extensions to the core Java libraries.
- Application Class Loader (also called System Class Loader):
- Loads classes from the application's classpath, which includes user-defined classes and libraries specified via the
  -cp
  or CLASSPATH environment variable.

### Linking

- The linking phase ensures that the loaded classes are valid and ready for use. It includes:

- Verification: Performed by the Bytecode Verifier, which checks if the bytecode is valid, generated by a legitimate
  compiler, and safe to execute.
- It ensures:
- No invalid opcodes or malicious code (e.g., viruses).
- Code adheres to Java’s security and type-safety rules (e.g., no illegal casts or stack overflows).
- Preparation: Allocates memory for static variables and assigns them default values (e.g., 0 for int, null for
  objects).
- Original values specified in the code are assigned during the initialization phase.
- Resolution: Resolves symbolic references (e.g., method or class names) to direct references by loading dependent
  classes.

### Initialization

- Assigns the original values to static variables and executes static initializers (e.g., static {} blocks).
  This phase completes the preparation of the class for execution.

## Memory Areas

- The JVM organizes memory into several runtime data areas to manage the execution of a Java program. These include:

### Method Area:

- Stores class-level data, such as bytecode, constant pool, method code, and static variables.
- Shared among all threads.

### Heap Area:

- Stores all object instances and arrays.
- Divided into generations (Young, Old, and Permanent/Metaspace in newer JVMs) for efficient garbage collection.

### Stack Area:

- Each thread has its own stack, which stores method call frames.
- Each frame contains local variables, operand stack, and a reference to the method’s constant pool.

### PC Register (Program Counter Register):

- Each thread has a PC register that holds the address of the currently executing JVM instruction.

### Native Method Stack:

- Used for executing native methods (written in languages like C/C++).

## Execution Engine

- The Execution Engine is responsible for executing the bytecode loaded into memory. It includes two main components:
  the Interpreter and the JIT Compiler, along with supporting mechanisms like the Garbage Collector.

### Interpreter

- Reads, interprets, and executes the bytecode line by line.
- Fast to start but slower for repeated execution because it interprets the same bytecode each time.
- Ensures platform independence by executing bytecode in a controlled environment.

### Just-In-Time (JIT) Compiler

- Improves performance by compiling frequently executed bytecode into native machine code, which can be executed
  directly
  by the hardware.
- The JIT Compiler activates only after a method has been executed at least once (to gather profiling data).
- Uses techniques like method inlining, loop unrolling, and dead code elimination to optimize performance.
- The compiled native code is cached, reducing the need for repeated interpretation.

### Garbage Collector

- Automatically manages memory in the heap by reclaiming memory occupied by objects no longer in use.
- Operates in the background, using algorithms like Mark-and-Sweep or Generational Collection.
- Ensures efficient memory usage and prevents memory leaks.

## Additional Components

### Native Method Interface (JNI):

- Allows Java code to interact with native applications or libraries written in languages like C/C++.
  Used for platform-specific operations or performance-critical tasks.

### Native Method Libraries:

- External libraries (e.g., .dll or .so files) loaded to support native method execution.

# Summary of JVM Workflow

- **Source Code:** Programmer writes .java files.
- **Compilation:** Java Compiler (javac) converts .java files to .class files (bytecode).
- **Class Loading:** The Class Loader Subsystem loads .class files into memory using Bootstrap, Extension, and
  Application Class Loaders.
- **Bytecode Verification:** The Bytecode Verifier ensures the bytecode is valid and safe.
- **Memory Allocation:** Static variables are allocated memory and assigned default values (Preparation), followed by
  original values (Initialization).
- **Execution:** The Execution Engine uses the Interpreter to execute bytecode line by line and the JIT Compiler to
  optimize frequently executed methods.
- **Garbage Collection:** The Garbage Collector manages memory by reclaiming unused objects.
- **Native Interactions:** JNI and native libraries handle platform-specific tasks when needed.