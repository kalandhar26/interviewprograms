# Java Stream Methods

- Streams are introduced in java 8. They allow processing of collections in a functional style chaining multiple
  operations togather.
- Streams do not store data, they process data.
- Streams are consumed once - you cannot reuse a stream after a terminal operation.
- Stream operations can be chained.
- prefer parallelStreams only when it can truely improve performance [large data + non-thread blocking code]

## Key Interfaces

- Stream<T>
- Instream, LongStream, DoubleStream

## Creation of Streams

| Method               | Description                                    | Example                          |
|----------------------|------------------------------------------------|----------------------------------|
| stream()             | Converts a collection into a sequential stream | list.stream()                    |
| parallelStream()     | converts collection into a parallel stream     | list.parallelStream()            |
| Stream.of(..)        | creates a stream from values                   | Stream.of(1,2,3)                 |
| Arrays.stream(array) | Creates a stream from a array                  | Arrays.stream(new int[] {1,2,3}) |

## Intermediate Operations (returns a new Stream, lazy evaluation)

- Intermediate Operations are lazy - no processing happens until a terminal operation is called.

| Method               | Description                                                                           | Example                                    |
|----------------------|---------------------------------------------------------------------------------------|--------------------------------------------|
| `filter(Predicate)`  | Keep only elements that satisfy the predicate                                         | `stream.filter(x -> x > 5)`                |
| `map(Function)`      | Transform each element with the provided function                                     | `stream.map(String::toUpperCase)`          |
| `flatMap(Function)`  | Flatten one-to-many structures into a single stream                                   | `stream.flatMap(list -> list.stream())`    |
| `distinct()`         | Remove duplicates (based on `equals()`)                                               | `stream.distinct()`                        |
| `sorted()`           | Sort by natural order                                                                 | `stream.sorted()`                          |
| `sorted(Comparator)` | Sort with a custom comparator                                                         | `stream.sorted(Comparator.comparing(...))` |
| `limit(n)`           | Truncate the stream to at most `n` elements                                           | `stream.limit(5)`                          |
| `skip(n)`            | Discard the first `n` elements                                                        | `stream.skip(3)`                           |
| `peek(Consumer)`     | Perform an action on each element without consuming the stream (mainly for debugging) | `stream.peek(System.out::println)`         |

## Terminal Operations (triggers Stream Processing)

| Method                   | Description                                                        | Typical Usage                                |
|--------------------------|--------------------------------------------------------------------|----------------------------------------------|
| `collect(Collector)`     | Gather elements into a collection or other container               | `stream.collect(Collectors.toList())`        |
| `forEach(Consumer)`      | Apply an action to each element                                    | `stream.forEach(System.out::println)`        |
| `toArray()`              | Convert the stream into an array                                   | `stream.toArray()`                           |
| `reduce(BinaryOperator)` | Combine elements into a single result via an associative operation | `stream.reduce(0, Integer::sum)`             |
| `count()`                | Count the number of elements                                       | `stream.count()`                             |
| `min(Comparator)`        | Return the smallest element according to the comparator            | `stream.min(Comparator.naturalOrder())`      |
| `max(Comparator)`        | Return the largest element according to the comparator             | `stream.max(Comparator.naturalOrder())`      |
| `anyMatch(Predicate)`    | Return `true` if **any** element matches the predicate             | `stream.anyMatch(x -> x > 0)`                |
| `allMatch(Predicate)`    | Return `true` if **all** elements match the predicate              | `stream.allMatch(x -> x > 0)`                |
| `noneMatch(Predicate)`   | Return `true` if **no** element matches the predicate              | `stream.noneMatch(x -> x < 0)`               |
| `findFirst()`            | Return the **first** element (order-preserving)                    | `stream.findFirst()` (returns `Optional<T>`) |
| `findAny()`              | Return **any** element (useful in parallel streams)                | `stream.findAny()` (returns `Optional<T>`)   |

## Collectors (used with collect)

| Collector Factory                          | Purpose                                               | Example                                                            |
|--------------------------------------------|-------------------------------------------------------|--------------------------------------------------------------------|
| `Collectors.toList()`                      | Collect elements into a `List`                        | `stream.collect(Collectors.toList())`                              |
| `Collectors.toSet()`                       | Collect elements into a `Set`                         | `stream.collect(Collectors.toSet())`                               |
| `Collectors.toMap(keyMapper, valueMapper)` | Collect elements into a `Map`                         | `stream.collect(Collectors.toMap(Person::getId, Person::getName))` |
| `Collectors.groupingBy(Function)`          | Group elements by a key extractor function            | `names.stream().collect(Collectors.groupingBy(String::length))`    |
| `Collectors.partitioningBy(Predicate)`     | Partition the stream into two groups (`true`/`false`) | `stream.collect(Collectors.partitioningBy(x -> x > 10))`           |
| counting()                                 | Count Elements                                        | Collectors.counting()                                              |
| averagingDouble()                          | calculate average                                     | Collectors.averagingDouble(Employee::getSalary)                    |
| summingDouble()                            | Calculate Sum                                         | Collectors.summingDouble(Employee::getSalary)                      |

## Premitive Specializations

| Primitive Stream | Factory / Range                | Key Methods                            |
|------------------|--------------------------------|----------------------------------------|
| `IntStream`      | `IntStream.range(1, 5)`        | `sum()`, `average()`, `min()`, `max()` |
| `LongStream`     | `LongStream.rangeClosed(1, 5)` | `sum()`, `average()`, `min()`, `max()` |
| `DoubleStream`   | `DoubleStream.of(1.2, 3.4)`    | `sum()`, `average()`, `min()`, `max()` |

## Which design patterns are followed while implementing lambda expressions and streams?

- **Strategy Pattern** : lambda expressions allow defining different algorithms or behaviors inline without creating
  concrete class.
- Streams and lambdas abstract the behavior of operations like filtering, mapping and sorting, fitting the strategy
  pattern model.
- **Factory Pattern** : Lambdas may replace concrete implementations with functional factories for object creation.
- **Command Pattern** : Lambdas encapsulate a request or action as an object that can be passed, stored, and executed.
- Streams operations or event handlers often use lambdas as commands to be executed later, aligning with this pattern.

### Design Patterns in Streams

#### Strategy Pattern
- Lambda expressions allow defining different algorithms inline without creating concrete classes.

```java
// Different sorting strategies
Comparator<Employee> bySalary = Comparator.comparingDouble(Employee::getSalary);
Comparator<Employee> byAge = Comparator.comparingInt(Employee::getAge);
Comparator<Employee> byName = Comparator.comparing(Employee::getName);

employees.stream().sorted(bySalary);  // Salary strategy
employees.stream().sorted(byAge);     // Age strategy
employees.stream().sorted(byName);    // Name strategy
```

#### Factory Pattern
- Lambdas can replace concrete implementations with functional factories.
```java
Function<String, Employee> employeeFactory = name -> new Employee(name);
Supplier<List<Employee>> listFactory = ArrayList::new;
```

#### Command Pattern
- Lambdas encapsulate actions that can be passed and executed later.

```java
Runnable task = () -> processEmployees(employees);
ExecutorService executor = Executors.newFixedThreadPool(2);
executor.execute(task);
```

#### Observer Pattern
- Stream operations can be chained like observers.

```java
employees.stream()
    .filter(e -> e.getAge() > 25)        // Observer 1: Filter
    .map(Employee::getName)               // Observer 2: Transform
    .forEach(System.out::println);        // Observer 3: Action
```


# CODE SNIPPETS



# Streams Code snipper
## Number Operations

```java
List<Integer> numbers = Arrays.asList(1, 2, 8, 9, 10, 11, 14, 15, 17, 19, 4, 5, 6, 7, 8, 9);

// Remove duplicates
List<Integer> distinctNumbers = numbers.stream().distinct().toList();

// Get only duplicates
List<Integer> duplicates = numbers.stream()
    .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
    .entrySet().stream()
    .filter(entry -> entry.getValue() > 1)
    .map(Map.Entry::getKey)
    .toList();

// Get only unique numbers
List<Integer> uniqueNumbers = numbers.stream()
    .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
    .entrySet().stream()
    .filter(entry -> entry.getValue() == 1)
    .map(Map.Entry::getKey)
    .toList();

// Sum of squares of even numbers
int evenSquareSum = numbers.stream()
    .filter(num -> num % 2 == 0)
    .mapToInt(n -> n * n)
    .sum();

// Alternative using reduce
int evenSquareSumAlt = numbers.stream()
    .filter(num -> num % 2 == 0)
    .map(n -> n * n)
    .reduce(0, Integer::sum);

// First number greater than 5
int firstGT5 = numbers.stream()
    .sorted()
    .filter(num -> num > 5)
    .findFirst()
    .orElse(0);

// Check if all numbers are positive
boolean allPositive = numbers.stream().allMatch(num -> num > 0);

// Numbers as comma-separated string
String commaSeparated = numbers.stream()
    .map(String::valueOf)
    .collect(Collectors.joining(","));

// Third highest number
int thirdHighest = numbers.stream()
    .sorted()
    .skip(2)
    .findFirst()
    .orElse(0);

// Find Maximum
int maximum = numbers.stream()
                        .reduce(Integer.MIN_VALUE, (a,b)-> a > b ? a : b);

// Concatenate strings
String sentence = words.stream()
                        .reduce("", (a, b) -> a + " " + b);

```

## String Filtering Operations
```java
// Employees whose name starts with R
List<Employee> nameStartsWithR = employees.stream()
    .filter(emp -> emp.getName().toLowerCase().startsWith("r"))
    .toList();

// Employees whose name contains "reddy"
List<Employee> nameContainsReddy = employees.stream()
    .filter(emp -> emp.getName().toLowerCase().contains("reddy"))
    .toList();

// Parallel sum
int sum = numbers.parallelStream()
                 .mapToInt(Integer::intValue)
                 .sum();

// Large List Parallel Processing

List<Integer> bigList = IntStream.rangeClosed(1, 1_000_000)
                                 .boxed()
                                 .toList();
long count = bigList.parallelStream().filter(n -> n % 2 == 0).count();

// Flatten list of lists
List<String> flat = nestedList.stream()
                              .flatMap(Collection::stream)
                              .toList();

// Split sentences into words

List<String> sentences = Arrays.asList("Java is fun", "Streams are powerful");

List<String> words = sentences.stream()
                              .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
                              .toList();

```

## Maximum and Minimum

- maximum salary from employees
```java
Optional<Employee> maxSalariedEmployee = employees.stream().max(Comparator.comparingDouble(Employee::getSalary));
```
- minimum salary from employees
```java
Optional<Employee> maxSalariedEmployee = employees.stream().max(Comparator.comparingDouble(Employee::getSalary));
```
- Maximum Salary of an Employee Department wise
```java
employees.stream().collect)(Collectors.groupingBy(Employee::getName, Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));
```
- Minimum Salary of an Employee Department wise
```java
employees.stream().collect(Collectors.groupingBy(Employee::getName, Collectors.minBy(Comparator.comparingDouble(Employee::getSalary))));
```

- Youngest Employee
```java
employees.stream().min(Comparator.comparingInt(Employee::getAge)).map(Employee::getName).ifPresent(System.out::println);
```
- Oldest Employee
```java
employees.stream().min(Comparator.comparingInt(Employee::getAge)).map(Employee::getName).ifPresent(System.out::println);
```

- Youngest MALE Employee
```java
String youngestMaleEmployee = employees.stream().filter(employee -> employee.getGender.equals("MALE")).min(Comparator.comparingInt(Employee::getAge)).map(Employee::getName);
```
- Youngest Employee based on Gender Wise
```java
employees.stream().collect(Collectors.groupingBy(Employee::getGender, Collectors.minBy(comaprator.ComparingInt(Employee::getAge))));
```


```java
// Nested data flattening (Orders with Products)

List<String> productNames = orders.stream()
                                  .flatMap(order -> order.getProducts().stream())
                                  .map(p -> p.name)
                                  .toList();

                                  String[] wordsArray = {"one", "two", "three", "four", "five"};
// Parallel word count with reduce

String[] wordsArray = {"one", "two", "three", "four", "five"};

int totalLength = Arrays.stream(wordsArray)
                        .parallel()
                        .map(String::length)
                        .reduce(0, Integer::sum);
```


## Basic Filtering and Sorting Operations

```java
// Filter inactive employees
List<Employee> inactiveEmployees = employees.stream()
    .filter(emp -> emp.getStatus().equals("InActive"))
    .toList();

// Sort by salary ascending
List<Employee> sortedBySalaryAsc = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary))
    .toList();

// Sort by salary descending
List<Employee> sortedBySalaryDesc = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .toList();

// Sort by salary (alternative)
List<Employee> sortedBySalaryAlt = employees.stream()
    .sorted((e1, e2) -> (int) (e1.getSalary() - e2.getSalary()))
    .toList();
```

## Grouping Operations

```java
// Group by department
Map<Integer, List<Employee>> employeesByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid));

// Group by department name
Map<String, List<Employee>> employeesByDeptName = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

// Count employees by department
Map<Integer, Long> countByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid, Collectors.counting()));

// Count by department name
Map<String, Long> countByDeptName = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));
```

## Statistical Operations

```java
// Maximum salary
Optional<Employee> maxSalaried = employees.stream()
    .max(Comparator.comparingDouble(Employee::getSalary));

// Minimum salary
Optional<Employee> minSalaried = employees.stream()
    .min(Comparator.comparingDouble(Employee::getSalary));

// Maximum salary department wise
Map<Integer, Optional<Employee>> maxSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid, 
             Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));

// Minimum salary department wise
Map<Integer, Optional<Employee>> minSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid, 
             Collectors.minBy(Comparator.comparingDouble(Employee::getSalary))));
```

## Gender-Based Operations

```java
// Count male/female employees
Map<String, Long> genderCount = employees.stream()
    .collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));

// Average age by gender
Map<String, Double> avgAgeByGender = employees.stream()
    .collect(Collectors.groupingBy(Employee::getGender, 
             Collectors.averagingInt(Employee::getAge)));

// Highest paid employee by gender
Map<String, Optional<Employee>> highestPaidByGender = employees.stream()
    .collect(Collectors.groupingBy(Employee::getGender, 
             Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));
```

## Age-Based Operations

```java
// Youngest employee
Optional<Employee> youngest = employees.stream()
    .min(Comparator.comparingInt(Employee::getAge));

// Oldest employee
Optional<Employee> oldest = employees.stream()
    .max(Comparator.comparingInt(Employee::getAge));

// Youngest male employee
String youngestMale = employees.stream()
    .filter(e -> e.getGender().equals("MALE"))
    .min(Comparator.comparingInt(Employee::getAge))
    .map(Employee::getName)
    .orElse("Not found");

// Partition minors and majors
Map<Boolean, List<Employee>> partitionedByAge = employees.stream()
    .collect(Collectors.partitioningBy(emp -> emp.getAge() > 18));

// List minor employees
List<String> minorEmployees = employees.stream()
    .filter(e -> e.getAge() < 18)
    .map(Employee::getName)
    .toList();
```

## Salary Operations

```java
// Total salary expenditure
double totalSalary = employees.stream()
    .mapToDouble(Employee::getSalary)
    .sum();

// Average salary
double avgSalary = employees.stream()
    .collect(Collectors.averagingDouble(Employee::getSalary));

// Average salary by department
Map<String, Double> avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment, 
             Collectors.averagingDouble(Employee::getSalary)));

// Second highest paid employee
Optional<Employee> secondHighest = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .skip(1)
    .findFirst();

// Top N highest paid employees
int n = 3;
List<Employee> topN = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .limit(n)
    .toList();

// All employees except top N
List<Employee> exceptTopN = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .skip(n)
    .toList();
```

## Salary Modification Operations

```java
// Increase salary for employees above 20 (display only hiked)
List<Employee> hikedSalaries1 = employees.stream()
    .filter(emp -> emp.getAge() > 20)
    .peek(emp -> emp.setSalary(emp.getSalary() * 1.1))
    .toList();

// Increase salary for employees above 25 (display all)
List<Employee> hikedSalaries2 = employees.stream()
    .peek(emp -> {
        if (emp.getAge() > 25) {
            emp.setSalary(emp.getSalary() * 1.1);
        }
    })
    .toList();
```

## Department and Address Operations

```java
// Print all departments
employees.stream()
    .map(Employee::getDepartment)
    .distinct()
    .forEach(System.out::println);

// Group by city
Map<String, List<Employee>> byCity = employees.stream()
    .collect(Collectors.groupingBy(emp -> emp.getAddress().getCity()));

// Group by state
Map<String, List<Employee>> byState = employees.stream()
    .collect(Collectors.groupingBy(emp -> emp.getAddress().getState()));

// Employees from specific city and state
List<Employee> fromSpecificLocation = employees.stream()
    .filter(emp -> "AP".equalsIgnoreCase(emp.getAddress().getState()) 
                && "Pileru".equalsIgnoreCase(emp.getAddress().getCity()))
    .toList();
```

## Hobby Operations

```java
// Get all unique hobbies
List<String> allHobbies = employees.stream()
    .map(Employee::getHobbies)
    .flatMap(List::stream)
    .distinct()
    .toList();

// Count employees by hobby
Map<String, Long> countByHobby = employees.stream()
    .flatMap(emp -> emp.getHobbies().stream()
        .map(hobby -> new AbstractMap.SimpleEntry<>(hobby, emp)))
    .collect(Collectors.groupingBy(Map.Entry::getKey, Collectors.counting()));

// Employees with at least N common hobbies
int minCommonHobbies = 3;
Map<String, List<Employee>> byCommonHobbies = employees.stream()
    .flatMap(emp -> emp.getHobbies().stream()
        .map(hobby -> new AbstractMap.SimpleEntry<>(hobby.toLowerCase(), emp)))
    .collect(Collectors.groupingBy(Map.Entry::getKey, 
             Collectors.mapping(Map.Entry::getValue, Collectors.toList())));
```

## Complex Department Operations

```java
// Employees working in multiple departments
Map<String, List<Employee>> deptWiseEmployees = employees.stream()
    .flatMap(emp -> emp.getDepartments().stream()
        .map(dept -> new AbstractMap.SimpleEntry<>(dept.getName(), emp)))
    .collect(Collectors.groupingBy(AbstractMap.SimpleEntry::getKey, 
             Collectors.mapping(AbstractMap.SimpleEntry::getValue, Collectors.toList())));

// Employees working in at least 2 departments
List<String> multiDeptEmployees = employees.stream()
    .filter(emp -> emp.getDepartments().size() >= 2)
    .map(Employee::getName)
    .toList();

// Employee names with their departments
Map<String, List<String>> empDeptMapping = employees.stream()
    .collect(Collectors.toMap(Employee::getName, 
             emp -> emp.getDepartments().stream().map(Department::getName).toList()));
```

## Year-Based Operations

```java
// Employees passed out after 2020
List<Employee> recentGraduates = employees.stream()
    .filter(emp -> emp.getPassedOutyear() > 2020)
    .toList();

// Unique passout years in descending order
List<Integer> uniquePassoutYears = employees.stream()
    .map(Employee::getPassedOutyear)
    .distinct()
    .sorted(Comparator.reverseOrder())
    .toList();

// Duplicate passout years
List<Integer> duplicatePassoutYears = employees.stream()
    .map(Employee::getPassedOutyear)
    .filter(year -> employees.stream()
        .filter(emp -> emp.getPassedOutyear() == year).count() > 1)
    .distinct()
    .toList();
```

















