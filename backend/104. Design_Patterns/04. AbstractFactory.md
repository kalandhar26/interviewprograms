## Abstract Factory Pattern

- Abstract factory pattern creates families of related objects (e.g., all UI elements for Windows/Mac).
- The Abstract Factory pattern provides an interface to create families of related or dependent objects
  without specifying their concrete classes.
- This is useful when your system needs to be platform-independent or theme-based, where multiple families of related
  products need to be created together.
- Provide an interface for creating families of related objects (GUI toolkit, DB drivers) without specifying their
  concrete classes.

## PseudoCode

```text
1. create multiple product interfaces.
2. create concrete implementations for each product.
3. create a abstract factory interface that declares method for creating each product.
4. create concrete factories for each family.
5. client code uses the factory, not new. so it can works with any family.
```

## Scenario

- A Bank works in multiple regions: Retail Banking and Corporate Banking
- Each region needs: Account, Loan, and Card
- We should not mix Retail Account + Corporate Loan
- So each region is a family of related products.

## Example 1

### Step 1: Create Multiple Product Interfaces

```java
interface Account {
    void open();
}

interface Loan {
    void approve();
}
```

- These are banking products

### Step 2: Create Concrete Products (Retail Family)

```java
class RetailAccount implements Account {
    public void open() {
        System.out.println("Retail Account opened");
    }
}

class RetailLoan implements Loan {
    public void approve() {
        System.out.println("Retail Loan approved");
    }
}

class CorporateAccount implements Account {
    public void open() {
        System.out.println("Corporate Account opened");
    }
}

class CorporateLoan implements Loan {
    public void approve() {
        System.out.println("Corporate Loan approved");
    }
}

```

- Retail products go together and Corporate products go together.

### Step 3: Abstract Factory Interface

```java
interface BankingFactory {
    Account createAccount();

    Loan createLoan();
}
```

- This factory says: “I will give you a matching Account and Loan.”

### Step 4: Concrete Factories (Families)

```java
class RetailBankingFactory implements BankingFactory {

    public Account createAccount() {
        return new RetailAccount();
    }

    public Loan createLoan() {
        return new RetailLoan();
    }
}

class CorporateBankingFactory implements BankingFactory {

    public Account createAccount() {
        return new CorporateAccount();
    }

    public Loan createLoan() {
        return new CorporateLoan();
    }
}

```

- Each factory creates only its own family

### Step 5: Client Code (Bank Application)

```java
public class BankingAbstractFactoryDemo {

    public static void main(String[] args) {

        BankingFactory factory;

        // Decide banking type
        String customerType = "RETAIL"; // or CORPORATE

        if (customerType.equals("RETAIL")) {
            factory = new RetailBankingFactory();
        } else {
            factory = new CorporateBankingFactory();
        }

        Account account = factory.createAccount();
        Loan loan = factory.createLoan();

        account.open();
        loan.approve();
    }
}
```

- output:

```text
Retail Account opened
Retail Loan approved
```

- (Change type to CORPORATE)

```text
Corporate Account opened
Corporate Loan approved
```

- Abstract Factory Pattern is used in banking systems to create families of related products like accounts, loans, and
  cards for different banking types without mixing implementations.

------------------------

## Example 2

```java
// Step 1: Create multiple product interfaces
interface Button {
    void paint();
}

interface Checkbox {
    void paint();
}

// Step 2: Create concrete implementations for each product
class WinButton implements Button {
    public void paint() {
        System.out.println("WinButton");
    }
}

class MacButton implements Button {
    public void paint() {
        System.out.println("MacButton");
    }
}

class WinCheckbox implements Checkbox {
    public void paint() {
        System.out.println("WinCheckbox");
    }
}

class MacCheckbox implements Checkbox {
    public void paint() {
        System.out.println("MacCheckbox");
    }
}

// Step 3: Create an abstract factory interface 
//         that declares methods for creating each product
interface GUIFactory {
    Button createButton();

    Checkbox createCheckbox();
}

// Step 4: Create concrete factories for each family
class WinFactory implements GUIFactory {
    public Button createButton() {
        return new WinButton();
    }

    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }

    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

// Step 5: Client code uses the factory, not `new` directly
public class AbstractFactoryStepwiseDemo {
    public static void main(String[] args) {
        // Pick factory based on OS
        GUIFactory factory = System.getProperty("os.name").startsWith("Mac")
                ? new MacFactory()
                : new WinFactory();

        Button btn = factory.createButton();
        Checkbox chk = factory.createCheckbox();

        btn.paint();   // prints MacButton or WinButton
        chk.paint();   // prints MacCheckbox or WinCheckbox
    }
}
```

Output:

```text
WinButton
WinCheckbox
```

## Real Banking Use-Cases of Abstract Factory

✔ Retail vs Corporate Banking
✔ Domestic vs International Transactions
✔ Traditional Banking vs Conventional Banking
✔ Debit + Credit Card families
✔ Payment rules per country

- Factory → One Product
- Abstract Factory → Full Set of Products