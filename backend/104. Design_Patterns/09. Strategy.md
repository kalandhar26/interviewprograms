## Strategy Pattern

- Strategy Pattern allows you to choose one behavior from multiple options at runtime. Lets you switch algorithms at
  runtime (like choosing payment methods).
- The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. It allows
  the algorithm to vary independently of clients that use it.
- This is a behavioral design pattern that promotes flexibility and extensibility, often used when you have multiple
  ways to perform an operation like payment, sorting, or compression.
- Define a family of interchangeable algorithms and make them swappable at runtime.

## PseudoCode:

```text
1. Create a strategy interface (defines a common method)
2. Create a concrete Strategy classes (different implementations of the algorithm)
3. Create a context class (holds data and uses a Strategy Object)
4. The Context delegates the work to the chosen Strategy.
5. Client chooses which strategy to use at runtime. This makes algorithms interchangeable and swappable at runtime 
without changing the client code.
```

## Senario

## Example 1

### 1️⃣ Strategy Interface (Interest Calculation)
```java
interface InterestStrategy {
    double calculateInterest(double balance);
}

```

### Step 2️⃣ Concrete Strategies (Different Bank Rules)

```java
class SavingsInterestStrategy implements InterestStrategy {
    public double calculateInterest(double balance) {
        return balance * 0.04;
    }
}

class CurrentInterestStrategy implements InterestStrategy {
    public double calculateInterest(double balance) {
        return 0; // No interest
    }
}

class FixedDepositInterestStrategy implements InterestStrategy {
    public double calculateInterest(double balance) {
        return balance * 0.065;
    }
}
```
### Step 3️⃣ Context Class (Bank Account)

```java
class BankAccount {
    private InterestStrategy interestStrategy;

    public BankAccount(InterestStrategy interestStrategy) {
        this.interestStrategy = interestStrategy;
    }

    public void setInterestStrategy(InterestStrategy interestStrategy) {
        this.interestStrategy = interestStrategy;
    }

    public void calculateAnnualInterest(double balance) {
        double interest = interestStrategy.calculateInterest(balance);
        System.out.println("Annual Interest: " + interest);
    }
}
```
### Step 4️⃣ Client (Runtime Selection)
```java
public class BankingStrategyDemo {
    public static void main(String[] args) {

        BankAccount account = new BankAccount(new SavingsInterestStrategy());
        account.calculateAnnualInterest(100000);

        // Switch strategy at runtime
        account.setInterestStrategy(new FixedDepositInterestStrategy());
        account.calculateAnnualInterest(100000);

        account.setInterestStrategy(new CurrentInterestStrategy());
        account.calculateAnnualInterest(100000);
    }
}
```
- output
```text
Annual Interest: 4000.0
Annual Interest: 6500.0
Annual Interest: 0.0
```
--------------------------------
Example 2:

```java
// Step 1: Create Strategy Interface
interface PaymentStrategy {
    void pay(double amount);
}

// Step 2: Concrete Strategies
class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Credit Card.");
    }
}

class PayPalPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using PayPal.");
    }
}

class BankTransferPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid " + amount + " using Bank Transfer.");
    }
}

// Step 3: Context Class
class PaymentContext {
    private PaymentStrategy strategy;

    // Set strategy at runtime
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void payAmount(double amount) {
        if (strategy == null) {
            System.out.println("No payment method selected.");
        } else {
            strategy.pay(amount);
        }
    }
}

// Step 4: Client
public class StrategyPatternDemo {
    public static void main(String[] args) {
        PaymentContext context = new PaymentContext();

        // Use Credit Card
        context.setPaymentStrategy(new CreditCardPayment());
        context.payAmount(100.0);

        // Use PayPal
        context.setPaymentStrategy(new PayPalPayment());
        context.payAmount(200.0);

        // Use Bank Transfer
        context.setPaymentStrategy(new BankTransferPayment());
        context.payAmount(300.0);
    }
}
```

Output:

```text
Paid 100.0 using Credit Card.
Paid 200.0 using PayPal.
Paid 300.0 using Bank Transfer.

```

- **Example 2**

```java
// Step 1: Create a strategy interface
interface Strategy {
    void execute();
}

// Step 2: Create concrete strategy classes
class StrategyA implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy A");
    }
}

class StrategyB implements Strategy {
    public void execute() {
        System.out.println("Executing Strategy B");
    }
}

// Step 3: Create a context class
class Context {
    private Strategy strategy;

    // Set the strategy at runtime
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    // Step 4: Context delegates work to chosen strategy
    public void doWork() {
        if (strategy == null) {
            System.out.println("No strategy selected");
        } else {
            strategy.execute();
        }
    }
}

// Step 5: Client chooses strategy at runtime
public class StrategyPatternSimpleDemo {
    public static void main(String[] args) {
        Context context = new Context();

        context.setStrategy(new StrategyA());  // choose Strategy A
        context.doWork();

        context.setStrategy(new StrategyB());  // switch to Strategy B
        context.doWork();
    }
}
```

Output:

```text
Executing Strategy A
Executing Strategy B
```