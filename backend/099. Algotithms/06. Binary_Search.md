# Binary Search

- Binary Search is an efficient algorithm for finding a target element in a sorted array or list. It works by repeatedly
  dividing the search interval in half, eliminating half of the remaining elements each time. This makes it much faster
  than Linear Search for large datasets.

## Key Characteristics:

- Best Case: O(1) – Target is at the middle position.
- Worst Case: O(log n) – Target is at the edge or not present (where n is the array size; it halves the search space
  each step).
- Average Case: O(log n).
- Space Complexity: O(1) – Iterative version; O(log n) for recursive due to call stack.
- Pros: Very fast for sorted data; logarithmic growth scales well.
- Cons: Requires the array to be sorted first (sorting adds O(n log n) if unsorted); doesn't work on unsorted data.

## How It Works (Step-by-Step):

- Ensure the array is sorted (ascending order assumed).
- Initialize two pointers: left at index 0 (start) and right at the last index (end).
- While left <= right:
    1. Calculate the middle index: mid = left + (right - left) / 2 (avoids integer overflow).
    2. If arr[mid] == target, return mid.
    3. If arr[mid] < target, discard the left half: set left = mid + 1.
    4. If arr[mid] > target, discard the right half: set right = mid - 1.

- If the loop ends without finding the target, return -1.
- This process halves the search space each iteration (e.g., for 1024 elements, max ~10 steps).

### Iterative Binary Search

```java
import java.util.Arrays;

public class BinarySearch {

    // Iterative Binary Search method
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;  // Avoid overflow

            if (arr[mid] == target) {
                return mid;  // Found: return index
            } else if (arr[mid] < target) {
                left = mid + 1;  // Search right half
            } else {
                right = mid - 1;  // Search left half
            }
        }
        return -1;  // Not found
    }

    public static void main(String[] args) {
        // Example sorted array
        int[] numbers = {2, 5, 8, 12, 16, 23, 38, 55, 71, 81};
        int target = 16;  // Element to search for

        // Perform the search
        int result = binarySearch(numbers, target);

        // Print the array for reference
        System.out.println("Sorted Array: " + Arrays.toString(numbers));

        // Output the result
        if (result != -1) {
            System.out.println("Element " + target + " found at index " + result);
        } else {
            System.out.println("Element " + target + " not found in the array.");
        }
    }
}
```

- output

```text
Sorted Array: [2, 5, 8, 12, 16, 23, 38, 55, 71, 81]
Element 16 found at index 4
```

### Recursive Binary Search

#### How It Works (Step-by-Step):

- Base Cases: If the array is empty (left > right) or the subarray has no elements, return -1 (not found).
- Calculate the middle index: mid = left + (right - left) / 2.
    1. If arr[mid] == target, return mid.
    2. If arr[mid] < target, recurse on the right half: call the function with left = mid + 1 and same right.
    3. If arr[mid] > target, recurse on the left half: call the function with same left and right = mid - 1.
- The recursion unwinds when the base case is hit or the target is found.

```java
import java.util.Arrays;

public class RecursiveBinarySearch {

    // Recursive Binary Search method (helper with left and right indices)
    public static int binarySearch(int[] arr, int target, int left, int right) {
        // Base case: search space exhausted
        if (left > right) {
            return -1;
        }

        int mid = left + (right - left) / 2;  // Avoid overflow

        // Base case: found target
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            // Recurse on right half
            return binarySearch(arr, target, mid + 1, right);
        } else {
            // Recurse on left half
            return binarySearch(arr, target, left, mid - 1);
        }
    }

    // Public wrapper method for simplicity (starts with full array)
    public static int binarySearch(int[] arr, int target) {
        return binarySearch(arr, target, 0, arr.length - 1);
    }

    public static void main(String[] args) {
        // Example sorted array
        int[] numbers = {2, 5, 8, 12, 16, 23, 38, 55, 71, 81};
        int target = 16;  // Element to search for

        // Perform the search
        int result = binarySearch(numbers, target);

        // Print the array for reference
        System.out.println("Sorted Array: " + Arrays.toString(numbers));

        // Output the result
        if (result != -1) {
            System.out.println("Element " + target + " found at index " + result);
        } else {
            System.out.println("Element " + target + " not found in the array.");
        }
    }
}
```

- output 