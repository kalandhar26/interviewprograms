# Merge Sort

- Merge Sort is a classic divide-and-conquer sorting algorithm that recursively divides the input array into two halves,
  sorts each half independently, and then merges the two sorted halves into a single sorted array. Invented by John von
  Neumann in 1945, it's particularly useful for linked lists or external sorting (large data that doesn't fit in memory)
  due to its predictable performance.

## Key Characteristics:

- Best/Average/Worst Case: O(n log n) – Consistent across all cases due to balanced divisions.
- Space Complexity: O(n) – Requires a temporary array for merging (not in-place).
- Pros: Stable (preserves relative order of equal elements); guaranteed O(n log n); parallelizable.
- Cons: Extra space usage; not as cache-efficient as in-place sorts like Quick Sort for small arrays.

## How It Works (Step-by-Step):

- Divide: Recursively split the array into two halves until each sub-array has 1 element (base case: already sorted).
- Conquer: Sort the sub-arrays (recursion handles this).
- Merge: Combine two sorted sub-arrays into one by comparing elements and placing the smaller one first in a temporary
  array, then copy back to the original.
- The process forms a recursion tree of depth log n, with merging at each level taking O(n) time total.
- Merging uses two pointers to traverse the sub-arrays efficiently.

```java
import java.util.Arrays;

public class MergeSort {
    
    // Main Merge Sort method: sorts sub-array from low to high
    public static void mergeSort(int[] arr, int low, int high) {
        if (low < high) {  // Base case: more than one element
            int mid = low + (high - low) / 2;  // Avoid overflow
            
            // Recursively sort left half
            mergeSort(arr, low, mid);
            
            // Recursively sort right half
            mergeSort(arr, mid + 1, high);
            
            // Merge the two sorted halves
            merge(arr, low, mid, high);
        }
    }
    
    // Merge two sorted sub-arrays: arr[low..mid] and arr[mid+1..high]
    private static void merge(int[] arr, int low, int mid, int high) {
        // Calculate sizes of two sub-arrays
        int leftSize = mid - low + 1;
        int rightSize = high - mid;
        
        // Create temporary arrays
        int[] left = new int[leftSize];
        int[] right = new int[rightSize];
        
        // Copy data to temp arrays
        for (int i = 0; i < leftSize; i++) {
            left[i] = arr[low + i];
        }
        for (int j = 0; j < rightSize; j++) {
            right[j] = arr[mid + 1 + j];
        }
        
        // Merge the temp arrays back into arr[low..high]
        int i = 0, j = 0, k = low;
        while (i < leftSize && j < rightSize) {
            if (left[i] <= right[j]) {  // Stable: <= preserves order
                arr[k++] = left[i++];
            } else {
                arr[k++] = right[j++];
            }
        }
        
        // Copy remaining elements of left (if any)
        while (i < leftSize) {
            arr[k++] = left[i++];
        }
        
        // Copy remaining elements of right (if any)
        while (j < rightSize) {
            arr[k++] = right[j++];
        }
    }
    
    // Public wrapper for full array
    public static void mergeSort(int[] arr) {
        mergeSort(arr, 0, arr.length - 1);
    }
    
    public static void main(String[] args) {
        // Example unsorted array
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        
        // Print original array
        System.out.println("Original Array: " + Arrays.toString(numbers));
        
        // Perform Merge Sort
        mergeSort(numbers);
        
        // Print sorted array
        System.out.println("Sorted Array: " + Arrays.toString(numbers));
    }
}
```

- output

```text
Original Array: [64, 34, 25, 12, 22, 11, 90]
Sorted Array: [11, 12, 22, 25, 34, 64, 90]
```