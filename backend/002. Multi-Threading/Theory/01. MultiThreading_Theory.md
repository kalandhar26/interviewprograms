### 1. What is life Cycle of a Thread?

- **New**: The thread has been created but has not yet started.
- **Runnable**: After calling start(), the thread is ready to run and waiting for CPU time.
- **Running** – The thread is currently executing.
- **Blocked**: The thread is waiting for a lock to enter a synchronized block or method.
- **Waiting**: The thread is waiting for another thread to perform a specific action.The thread is paused, either
  waiting for a resource or waiting for another thread’s action.
- **Timed Waiting**: The thread is waiting for another thread to perform an action for a specified period of time.
- **Terminated**: The thread has completed its execution. The thread has finished execution or has been stopped.

### 2. What are the Different ways to create threads in Java?

- There are two ways to create threads in Java:
- By extending the Thread class.

```java
class Main extends Thread {
    public void run() {
        System.out.println("thread is running");
    }

    public static void main(String args[]) {
        Main thread1 = new Main();
        thread1.start();
    }
}
```

- By implementing a Runnable interface.

```java
class Main implements Runnable {
    public void run() {
        System.out.println("thread is running");
    }

    public static void main(String args[]) {
        Main obj = new Main(); // Here we are Using the constructor Thread(Runnable r)
        Thread tobj = new Thread(obj);
        tobj.start();
    }
}
```

### 3. What is the difference between Thread and Runnable?

- Thread is a class present in java.lang package. Runnable is an interface present in java.lang package.
- Thread class provides thread scheduling functionality. Runnable interface does not provide thread scheduling
  functionality.
- Thread class implements Runnable interface.
- Thread class provides thread life cycle management functionality. Runnable interface does not provide thread life
  cycle management functionality.
- Thread class provides thread priority management functionality. Runnable interface does not provide thread priority
  management functionality.
- Thread class provides thread synchronization functionality. Runnable interface does not provide thread synchronization
  functionality.
- Thread class provides thread interruption functionality. Runnable interface does not provide thread interruption
  functionality.
- Thread class provides thread join functionality. Runnable interface does not provide thread join functionality.
- Thread class provides thread yield functionality. Runnable interface does not provide thread yield functionality.
- Thread class provides thread sleep functionality. Runnable interface does not provide thread sleep functionality.
- Thread class provides thread dump functionality. Runnable interface does not provide thread dump functionality.

### 4. Explain Synchronization mechanisms, thread pools, and the ForkJoinPool framework?

- **Synchronization mechanisms**
- Synchronization in Java is used to control access to shared resources when multiple threads are running. It makes sure
  that only one thread can use a method or code block at a time.
- The synchronized keyword helps avoid problems like data inconsistency or unexpected behavior caused by concurrent
  access.

```java
public synchronized void accessResource() {
    // only one thread can execute this at a time
}
```

- **Thread Pools**
- A Thread Pool is a group of ready-to-use threads that wait to perform tasks. Instead of creating a new thread for
  every task (which is slow and costly), tasks are given to these pre-created threads, improving performance.

Java provides ExecutorService, which is a high-level tool to manage thread pools. It allows you to:

Track task progress using Future objects for asynchronous operations.
Submit tasks easily
Shut down threads properly

```java
public class ExecutorServiceExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        executor.submit(() -> {
            System.out.println("Running in a thread pool!");
        });
        executor.shutdown();
    }
}
```

- **ForkJoinPool framework**
- ForkJoinPool is a special implementation of ExecutorService in Java that helps take advantage of multi-core
  processors. It works by:
- Forking (splitting) a big task into smaller subtasks
- Processing them in parallel
- Then joining the results together
- It’s ideal for recursive and parallelizable tasks, like sorting large arrays or processing big data sets.

```java
public class ForkJoinPoolExample {
    public static void main(String[] args) {
        ForkJoinPool forkJoinPool = new ForkJoinPool();
        forkJoinPool.submit(() -> {
            // perform some parallel computation
        });
        forkJoinPool.shutdown();
    }
}
```

### 5. What is Executor Framework?

- The Executor Framework in Java is a part of the java.util.concurrent package that provides a powerful and flexible way
  to manage and run multiple threads easily. It decouples task submission from thread management by using Executor,
  ExecutorService, and ThreadPoolExecutor. Instead of manually creating and managing threads, you can simply submit
  tasks (Runnable or Callable) and let the framework handle thread reuse, scheduling, and pooling that make your code
  cleaner, more efficient, and scalable.

### 6. How do you create a thread pool using Executor Framework?

- A thread pool is a group of worker threads that are ready to perform tasks. Instead of creating a new thread every
  time
  you have a job, you take one from the pool. This saves time and resources.

```java
public class ExecutorFrameworkPoolExample {

}

ExecutorService executor = Executors.newFixedThreadPool(5);

public static void main(String[] args) {
    ExecutorService executor = Executors.newSingleThreadExecutor();  // Only one thread executes at a time
    ExecutorService executor = Executors.newFixedThreadPool(5); // This creates a thread pool with 5 threads.
    ExecutorService executor = Executors.newCachedThreadPool();      // Dynamically creates new threads as needed

    executor.shutdown();
}
```

### 7. How do you create threads using Executor Framework?

- Steps to create threads using Executor Framework:

    1. Create a task using Runnable or Callable.
    2. Create an ExecutorService using Executors class.
    3. Submit the task to ExecutorService.
    4. It will automatically create and manage threads to run the tasks.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    public static void main(String[] args) {// Step 1: Create ExecutorService
        ExecutorService executor = Executors.newFixedThreadPool(3);// Step 2: Create and submit tasks (threads are created internally)
        executor.submit(new MyTask());
        executor.submit(new MyTask());
        executor.submit(new MyTask());// Step 3: Shutdown executor
        executor.shutdown();
    }
}

class MyTask implements Runnable {
    public void run() {
        System.out.println("Running in thread: " + Thread.currentThread().getName());
    }
}
```

### 8. Have you used Future and CompletableFuture?

- Yes, I have used both Future and CompletableFuture in Java for handling asynchronous tasks.
- Future is used when I want to execute a task in a separate thread and get the result later, but it has some
  limitations. Represents a result that will be available in the future. Used with ExecutorService.

```java
public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> future = executor.submit(() -> {
            Thread.sleep(1000);
            return 10;
        });
        Integer result = future.get(); // blocks until result is ready
    }
}
```

- CompletableFuture is more powerful — it supports chaining, callbacks, and non-blocking programming, which makes it
  very useful in real-world async operations like API calls or file processing. Can run tasks in the background, chain
  them, and add callbacks when done

```java
public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            return 10;
        });
        future.thenApply(result -> result * 2)
                .thenAccept(finalResult -> System.out.println("Final Result: " + finalResult));
    }
}
```

- Non-blocking
- Supports task chaining (thenApply, thenAccept)
- Exception handling (exceptionally, handle)
- Parallel execution (thenCombine, allOf, anyOf)

