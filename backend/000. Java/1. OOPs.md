### 1. Method Overloading

- Method Overloading occurs when two or more methods in the same class have the same name but different parameters (
  different type, number, or both). It helps in increasing the readability of the program.

```java
class Overloading {

    void display() {
        System.out.println("Display method");
    }

    void display(int a) {
        System.out.println("Display method with int parameter");
    }

    void display(String a) {
        System.out.println("Display method with String parameter");
    }
}
```

### 2. Method Overriding

- Method Overriding occurs when a subclass has a method with the same name and parameters as a method in its superclass.
- In overriding, the method in the subclass is used instead of the one in the superclass, allowing for dynamic method
  dispatch and polymorphism.

```java
// Method Overriding
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Cat extends Animal {
    void eat() {
        System.out.println("Cat eats fish.");
    }
}
//eat() method overridden
```

### 3. Method Hiding

- Method Hiding occurs when a subclass defines a static method with the same name and method signature as a static
  method in its superclass.
- The method to be executed is decided at compile time, based on the reference type, not the object type. Unlike method
  overriding, method hiding does not support runtime polymorphism.

```java
class Parent {
    static void show() {
        System.out.println("Parent static show()");
    }
}

class Child extends Parent {
    static void show() {
        System.out.println("Child static show()");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Parent();
        Parent c = new Child();
        Child ch = new Child();

        p.show();   // Parent static show()
        c.show();   // Parent static show()
        ch.show();  // Child static show()
    }
}

```

### What is Polymorphism?

- Polymorphism in Java is the ability of an object to take on many forms. It lets us perform a single action in
  different ways. Java supports polymorphism through method overriding (runtime polymorphism) and method overloading (
  compile-time polymorphism).

```java
class Bird {
    void fly() {
        System.out.println("Bird flies.");
    }
}

class Parrot extends Bird {
    void fly() {
        System.out.println("Parrot is flying.");
    }
}
```

### 1. What is OOPS?

- OOPS stands for Object-Oriented Programming System (commonly called Object-Oriented Programming â€“ OOP).
- It is a programming paradigm that organizes software design around objects, rather than functions or procedures.

#### Core Idea

- An object combines:
- Data (State) â†’ variables
- Behavior â†’ methods
- Objects interact with each other to build applications.

#### Why OOPS?

- Mimics real-world modeling
- Makes code:
- Modular
- Reusable
- Easy to maintain
- Scalable for large applications

#### In a banking application:

- BankAccount is a class
- balance is data
- withdraw() is behavior

```java
class BankAccount {
    double balance;

    void withdraw(double amount) {
        balance -= amount;
    }
}
```

### 2. What are the Four Pillars of OOPS?

- Encapsulation
- Inheritance
- Polymorphism
- Abstraction
- These principles work together to build robust, flexible, and secure applications.

### 3. Difference Between Class and Object

- Aspect Class Object
- Definition Blueprint or template Real instance of class
- Memory No memory allocated Occupies memory
- Nature Logical Physical
- Creation Defined once Can create multiple
- Example class Car {} Car c = new Car();

### Analogy

- Class â†’ Cookie cutter
- Object â†’ Actual cookie ðŸª

### 4. What is Encapsulation?

- Encapsulation is the process of wrapping data and methods into a single unit (class) and restricting direct access to
  the data.

#### Why Encapsulation?

- Data hiding
- Better security
- Controlled access
- Easy maintenance

#### Example

```java
class BankAccount {
    private double balance;

    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        if (amount > 0) balance += amount;
    }

}
```

- Here, balance cannot be accessed directly.

### 5. How is Encapsulation Achieved in Java?

- Private fields
- Public getters and setters
- Access modifiers

```java
public void setBalance(double amount) {
    if (amount >= 0) {
        balance = amount;
    }
}
```

### 6. What is Abstraction?

- Abstraction means hiding implementation details and exposing only essential features.
- Focus

### What to do

- Not how it is done

```java
abstract class Shape {
    abstract void draw();
}
```

- User only knows draw() exists â€” not how it is implemented.

### 7. Abstract Class vs Interface

- Feature Abstract Class Interface
- Variables Instance variables allowed Only constants
- Constructors Yes No
- Inheritance Single Multiple
- Methods Abstract + concrete Abstract, default, static

#### Use Case

- Abstract class â†’ Base functionality
- Interface â†’ Capability / contract

### 8. Can an Interface Have Method Implementation?

- Yes (Java 8+)

#### Types

- Default methods
- Static methods

```
interface Vehicle {
default void start() {
System.out.println("Engine started");
}

    static void honk() {
        System.out.println("Beep");
    }

}
```

### 9. What is Inheritance?

- Inheritance allows a child class to acquire properties and behavior of a parent class using extends.

```java
class Animal {
    void eat() {
    }
}

class Dog extends Animal {
    void bark() {
    }
}
```

#### Benefits

- Code reuse
- Logical hierarchy

### 10. Types of Inheritance in Java

#### Supported:

- Single
- Multilevel
- Hierarchical
- Multiple (via classes)âŒ Not supported:
- âœ” Achieved using interfaces

### 11. What is Polymorphism?

- Polymorphism means one interface, multiple implementations.

```java
Animal a = new Dog();
a.

sound();
```

#### Types

- Compile-time
- Runtime

### 12. Compile-Time vs Runtime Polymorphism

- Aspect Compile-Time Runtime
- Mechanism Method overloading Method overriding
- Binding Static Dynamic
- Decision Compile time Runtime

### 13. What is Method Overloading?

- Same method name, different parameters.
- int add(int a, int b);
- double add(double a, double b);

### 14. What is Method Overriding?

- Child class provides its own implementation of parent method.

```java
class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Bark");
    }
}
```

### 15. Rules for Overriding

- Same method signature
- Access level cannot be reduced
- Covariant return allowed
- Cannot override static/final/private methods

### 16. What is super Keyword?

- Refers to parent class object.
- super.method();
- super();

### 17. What is this Keyword?

- Refers to current object.
- this.name = name;

### 18. Can Constructor Be Overridden?

- âŒ No
- Constructors are not inherited.

### 19. Can Constructor Be Overloaded?

- âœ… Yes

```java
Dog() {
}

Dog(String name) {
}
```

### 20. What is Association?

- A HAS-A relationship between objects.

```java
class Student {
    Course course;
}

```

### 21. Aggregation vs Composition

- Aspect Aggregation Composition
- Relationship Weak Strong
- Lifecycle Independent Dependent
- Example Car â†’ Wheel House â†’ Room

### 22. What is Dynamic Binding?

- Method call resolved at runtime.

```java
Animal a = new Dog();
a.

sound();
```

### 23. What is Static Binding?

- Resolved at compile time.
- Overloading
- Static methods

### 24. What is Marker Interface?

- Interface with no methods.
- Examples: Serializable, Cloneable

### 25. Why Java Doesnâ€™t Support Multiple Inheritance?

- To avoid Diamond Problem and ambiguity.

### 26. What is Diamond Problem?

- When two parent classes have the same method, child becomes confused.
- Java avoids it using:
- Single inheritance
- Multiple interfaces

### 27. Can We Override Static Methods?

- âŒ No
- Static methods are hidden, not overridden.

### 28. What is Object Cloning?

- Creating an exact copy using clone().

```java

class Employee implements Cloneable {
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

### 29. What is Shallow Copy vs Deep Copy?

| Aspect     | Shallow Copy   | Deep Copy       |
|------------|----------------|-----------------|
| Copies     | References     | Actual objects  |
| Dependency | Shared         | Independent     |
| Use        | Simple objects | Complex objects |

### 30. Why is OOPS Important?

- Reusability
- Scalability
- Maintainability
- Security
- Real-world modeling

### 31. What happens internally when you create an object using new in Java?

- When we create an object using new, Java does several steps behind the scenes
- Memory allocation : Java first creates space in memory (heap) for the new object.
- Default Values are set : Java sets default values for all member variables of the class. 0 for numbers, false for
  boolean and null for objects.
- Constructor call : After that constructor runs. It sets the value we pass and run any setup code.
- Reference assignment and returns : Java creates a reference variable and assigns it to the object. the reference of
  the object is returned and store in variable.
- new means, make space -> set defaults -> run constructor -> give us the Object.

### 32. Can we create an object without using the new keyword? If yes How?

- Yes, we can create an object without using the new keyword. There are two ways to do this:
- Using newInstance() method of Class class
- Using clone() method of Object class
- Using Reflection
- Using deserialization
- Using Factory Methods.

### 33. Can a class be declared without any variables or methods?

- Yes, a class can be declared without any variables or methods. Java still creates a .class file, it still has a
  default constructor and we can create its objects. When we need a class just to represent its type so we create empty
  class like this and this is also called as a marker class.

### 34. Difference between object and object reference?

- First, Object and Object reference are two different things.
- Object is a real data, stored in heap and created using new keyword or newInstance() method of Class class or clone()
  method of Object class or deserialization or Factory Methods.
- Object reference is a variable that holds the memory address of the object. It is stored in stack memory and used to
  access the object.

### 35. Does assigning null to a reference delete the object?

- No, assigning null to a reference does not directly delete the object. Lets say again we have Student s = new
  Student().
- When we do s=null, the reference is removed, the object is still there but unreachable.
- The Object is not immediately destroyed but it becomes eligible for garbage collection. Garbage will remove it later.

### 36. Can a class have only static members? If yes then is it still be object oriented?

- Yes, a class can have only static members but conceptually object-oriented is about objects having data + behavior and
  static methods belongs to the class, not to objects so such class is more procedural style than pure object-oriented.

### 37. Is encapsulation only about making variables private?

- No, encapsulation is not only about making variables private. Encapsulation means, keeping data safe by making
  variables private and controlling how it is access by getters and setters.

### 38. If a class has private fields but public setters, is it truly encapsulated?

- It is partially encapsulated, but not always "truly" encapsulated. If setter method is allowing any value, it means
  data is not really protected.
- Private fields + Public Setter is just basic encapsulation.
- True Encapsulation needs validation and business rules in the setter methods.
- If there is field age and setAge method, so we cannot set negative number in the age attribute so we must have
  validation inside the setter method and that's what a true encapsulation.

### 39. Why do we use getters Setters when we can make fields public and setting getting directly?

- Encapsulation is hiding data by private methods and how it is accessed by getter and setters so we must hide fields by
  making them private.

### 40. What are anonymous classes?

- An anonymous class is a class without a name. It is created and used at the same time, usually when we need a small
  piece of custom behavior only once.
- Instead of creating a separate class file, we write the class directly where we need it.

### 41. Difference between Encapsulation and Abstraction?

- Encapsulation means hiding data and controlling access to it. We wrap data(variables) and code (methods) togather in a
  class and decide who can access them.
- Abstraction means hiding internal working and showing only what is necessary to the client. Client knows what an
  object does but does not know how it does it.

### 42. What problem does abstraction solve that encapsulation does not?

- Encapsulation only protects data. But abstraction solves the problem of complexity and reduces the coupling between
  classes.
- Where as Abstraction allows the user to work with high level ideas instead of low level details.

### 43. What is the difference between abstract class and interface? Why do we need abstract classes when already have interface?

- Abstract classes and interfaces both support abstraction, but they are used for different needs.
- We should use abstract class when classes are closely related and share code.
- Ex : Vehicle abstract Class, Car and Bike are extending it. Car and Bike can share the common methods in vehicle like
  accelerate.
- We should use interface when many unrelated classes need to follow the same rule.
- Ex : Payment interface and every Payment type has a unique implementation like CardPayment, UPIPayment,
  NetBankingPayment.
- Abstract classes can have both abstract methods (which do not have an implementation and must be implemented by
  subclasses) and concrete methods (which have an implementation).
- Interfaces can only have abstract methods (until Java 8, when default and static methods were added) and static
  constants.
- Abstract classes can have a constructor, while interfaces cannot.
- Abstract classes can have fields that are not static and final, while interfaces can only have static and final
  fields (until Java 8, when default methods were added).
- In Short, If we need constructor and instance variable so we must use abstract classes otherwise interfaces.

### 44. Can a abstract class exist without any abstract methods?

- Yes, an abstract class can exist without any abstract methods.
- Without abstract methods, it is likely made for only inheritance.

### 45. Why can an interface not have instance variables?

- Interface is a contract, not an object blueprint.
- Instance variables belong to objects
- Interfaces does not create object. So it cannot hold object state.
- That why all variables in interface are : public static final by default.

### 46. Why default, static and private methods are introduced in interfaces after java 8 or 9?

- "Default Methods" : If we add a new method in interface before java 8, All existing class would break; so that why
  default method was introduced.
- After Java 8 : We can have new methods as default in interfaces without breaking existing functionality.
- "Static Methods" : Static methods are just helper methods. They Avoid creating extra utility classes.
- "Private Methods" : They are used to share common logic between default methods and avoid duplication.

### 47. Why Java support multiple inheritance using interfaces but not classes?

- Java does not allow multiple inheritance with classes because it can create confusion and errors.
- If two parent classes have same method or variable name, the child class will not know which one to use. This is
  called the "diamond problem".
- But Java allows multiple inheritance with interfaces because interfaces mainly define method names, not full method
  code. So there is less confusion.
- Even when two interfaces have the same method, the child class must write its own implementation, so java clearly
  knows which code to use.

### 48. Can an interface exist without any methods?

- Yes, It's called a Marker Interface. A marker interface is an interface in java that has no methods. It is used to
  mark a class with some special meaning.
- Ex: Serializable, Clonable.

### 49. What exactly makes an interface a functional interface?

- An interface becomes a functional interface when it has exactly one abstract method.
- This single method represents the main work that the interface is supposed to do and because there is only one such
  method, it can be easily used with lambda expressions.
- If an interface has more than one abstract method, then it cannot be called a functional interface.

### 50. Can a functional interface have default methods and static methods?

- Yes, a functional interface can have default methods and static methods. These methods do not count as abstract
  methods. so they do not affect the "only one abstract method" rule.

### 51. Why is '@FunctionalInterface' optional but recommended?

- The '@FunctionalInterface' annotation is optional because the compiler can automatically detect whether an interface
  has only one abstract method. But it is recommended because it clearly tells other developers that this interface is
  meant to be used as a functional interface.
- It also protects the code by giving a compile time error, if some accidentally adds another abstract method.

### 52. Can a functional interface extend another interface?

- Yes, a functional interface can extend another interface, but only if the total number of abstract methods after
  extending is still one.
- If extending another interface adds more abstract methods and the total becomes more than one, then it will no longer
  be a functional interface.

### 53. Why cannot static methods be overridden and only hidden?

- Static methods belong to the class, not to the object.
- Overriding works with objects at runtime (runtime Polymorphism), but static methods are decided at compile time based
  on reference type.
- So when a child class has a static method with the same name, it does not override the parents method. It only hides
  it.

### 54. What is co-variant return type and why is it allowed?

- Covariant return type means that the overridden method in the child class can return a more specific type than the
  parents return type.
- Parent returns Animal and Child returns Dog. This is allowed because the child return type is still a kind of the
  parents type. So it fits wherever the parent type is expected.

### 55. Can we override main method?

- No, we cannot override the main method because it is static and static methods cannot be overridden. However a child
  class can define its own main method with the same signature but this is method hiding, not overriding.

### 56. Why is overloading resolved at compile time but overriding at runtime?

- Overloading depends on the method signature (method name + parameter types ) and is decided by the compiler by looking
  at the reference type and the arguments passed. So it is resolved at compile time.
- Overriding depends on the actual object created at runtime and java decides which method to call based on the object
  type. So it is resolved at runtime.

### 57. Can you overload a method by only changing the return type?

- No we cannot overload a method by only changing the return type. The compiler uses method name and parameter list to
  decide which method to call, not the return type.
- If only the return type is different, the compiler will get confused and give an error.

### 58. Can you overload static methods?

- Yes, static methods can be overloaded. As long as the parameter list is different, we can create multiple static
  methods with the same name in the same class.
- Overloading is about method signatures and static or non-static does not matter for overloading.

### 59. Can you overload main method?

- Yes, we can overload the main method by changing its parameter list. But the JVM will only call the exact method with
  the signature 'public static void main(String[] args)' to start the program.
- Other overloaded main methods will not be called automatically.

### 60. Can you overload private methods?

- Yes, Private methods can be overloaded within the same class by changing the parameter list.
- Overloading happens inside the same class and does not depend on inheritance, so access level does not matter.

### 61. Can an abstract class have a constructor?

- Yes, an abstract class can have a constructor. Even through we cannot create objects of an abstract class, its
  constructor is called when a child class object is created, to initialize the parent part of the object.

### 62. Why doesn't java allow static constructors?

- Java does not allow static constructors because static data is initialized using static blocks or static variable
  initialization.
- Constructors are meant to initialize objects and static members belong to the class, not to objects. So a static
  constructor does not fit the purpose.

### 63. Can a constructor call another constructor using this() and super()?

- Yes, a constructor can call another constructor using this() and super() to avoid code duplication.
- this() is used to call the constructor of the same class and super() is used to call the constructor of the parent
  class.
- We cannot use both this() and super() in the same constructor because it will create ambiguity on which constructor
  to call first.

### 64. Why are constructors not inherited, but accessible via super()?

- Constructors are not initialized because they are special methods meant only to create and initialize objects of their
  own class.
- But a child class can call the parents constructor using super() to make sure the parent part of the object is
  properly initialized.

### 65. What happen if you make all constructors private?

- If all constructors in a class are private, then other classes cannot create objects of that class, not even
  subclasses. This is because private constructors are only accessible within the class itself.
- This is used in patterns like Singleton, where we want to control completely prevet object creation from outside.

### 66. What problem arises with too many constructors?

- Too many constructors make the class hard to understand and use. Developers may get confused about which constructor
  to call and maintaining the code becomes difficult. It can also lead to duplicate logic in many constructor which
  increases bugs and makes changes risky.

### 67. Can a subclass in another package access a protected member via object reference?

- No, a subclass in another package cannot access a protected member via object reference. Protected members can only be
  accessed within the same package or through inheritance.

### 68. Why are interfaces methods always public, even if not specified?

- In Java, all interface methods are implicitly public, even if you don't specify the access modifier. This is because
  interfaces are meant to be implemented by different classes, and the implementation classes may have different access
  modifiers for the same method.
- By making all interface methods public, Java ensures that there is no access modifier mismatch when implementing the
  interface.

### 69. What happen if a class has no access modifier in a multi-module project?

- If a class has no access modifier in a multi-module project, it means that the class is package-private. This means
  that the class can only be accessed within the same package, and not from other packages.
- In a multi-module project, other modules usually use different packages, so they cannot access that class at all.

### 70. Can a class have multiple constructors with the same parameter list?

- No, a class cannot have multiple constructors with the same parameter list. Constructor overloading is not allowed
  based on return type.

### 71. Why can a top-level class not be private or protected?

- A top-level class cannot be private or protected because it needs to be accessible by other classes that are not in
  the same package. No other class outside its own file or hierarchy can access it, which would make it useless.

### 72. Can fields be public but still maintain encapsulation?

- In general, public fields break encapsulation because anyone can change them directly.
- However, if the field is final and immutable, it can still maintain encapsulation because it cannot be changed after
  initialization.

### 73. Can this() or super() can be used inside a static method?

- No, neither this nor super can be used inside a static method.
- A static method belongs to the class, not to any object. Therefore, it cannot use this or super because they refer to
  the current object and its parent, respectively.

### 74. Can super access private members of parent class?

- No, super cannot access private members of the parent class.
- Private members belongs only to class where they are defined. Even child classes cannot use them directly.

### 75. Can this() and super() can be used together in the same method?

- Yes, this and super can be used in the same method.
- this() is used to call the constructor of the same class and super() is used to call the constructor of the parent
  class.

### 76. What is the difference between Cohesion and Coupling?

- Cohesion refers to the degree to which a class's methods are related to each other and work together to achieve a
  common goal.
- Coupling refers to the degree to which a class is dependent on other classes to perform its task.

### 77. Difference between Aggregation and Composition?

- Aggregation is a weak association between two classes, where one class contains a reference to another class. The
  contained class can exist independently of the containing class.
- Composition is a strong association between two classes, where one class contains a reference to another class and the
  contained class cannot exist independently of the containing class.

### 78. Difference between Association, Aggregation, and Composition?

- Association is a general association between two classes, where one class uses the other class. The contained class
  can exist independently of the containing class.
- Aggregation is a weak association between two classes, where one class contains a reference to another class. The
  contained class can exist independently of the containing class.
- Composition is a strong association between two classes, where one class contains a reference to another class and the
  contained class cannot exist independently of the containing class.

### 79. Can a class have high cohesion but still be tightly coupled?

- abc

### 80. Is it possible to increase cohesion and coupling at the same time?

- abc



