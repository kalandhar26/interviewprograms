# Java Interview Questions

## 1. What are the differences between "==" and ".equals()" operators in Java?

*sol:*

- Difference Between `==` and `.equals()` in Java

| Feature                  | `==` Operator                                      | `.equals()` Method                                                                 |
|--------------------------|----------------------------------------------------|------------------------------------------------------------------------------------|
| **Purpose**              | Compares references (memory addresses)             | Compares object content (based on class implementation)                            |
| **Default Behavior**     | Checks if both references point to the same object | In `Object` class, same as `==`; overridden in many classes for content comparison |
| **Applicable To**        | All objects and primitives                         | All objects (must handle null checks carefully)                                    |
| **Used For**             | Reference comparison                               | Content comparison                                                                 |
| **Example - String**     | `s1 == s2` → `false` if different objects          | `s1.equals(s2)` → `true` if content is same                                        |
| **Example - Object**     | `o1 == o2` → `false` if different objects          | `o1.equals(o2)` → `false` unless overridden                                        |
| **Override Requirement** | Cannot be overridden                               | Can (and should) be overridden to define content equality                          |
| **Null Safety**          | Safe (returns false if any side is null)           | Can throw `NullPointerException` if the calling object is null                     |

## Code Examples

```java
class String {

    public static void main(String[] args) {
        String s1 = new String("hello");
        String s2 = new String("hello");

        System.out.println(s1 == s2);       // false: different objects
        System.out.println(s1.equals(s2));  // true: same content

        Object o1 = new Object();
        Object o2 = new Object();

        System.out.println(o1 == o2);       // false: different objects
        System.out.println(o1.equals(o2));// false: same as == in Object class
    }
}
```

## 2. Why String is immutable in Java?

**Security**

- Immutability ensures that String objects are safe in sensitive contexts, such as file paths, database connection URLs,
  or user credentials.
- If String were mutable, a malicious change to a shared String could compromise security. (e.g., in a library or API)
- For example, if a String containing a file path is passed to a method, immutability guarantees that the path won’t be
  altered unexpectedly.

**Thread Safety**

- Immutable objects are inherently thread-safe because their state cannot be changed after creation.
- Multiple threads can safely use the same String object without synchronization, reducing the risk of concurrency
  issues and improving performance in multithreaded applications.

**String Pool Optimization**

- Java maintains a string pool (a special area in the heap) to store unique String literals. Immutability allows strings
  with the same content to be reused from the pool, reducing memory usage and improving performance.
- For example, String s1 = "hello"; String s2 = "hello"; results in s1 and s2 referencing the same object in the string
  pool. If String were mutable, changing one would affect the other, breaking this optimization.

**Caching Hash Codes**

- The String class caches its hash code (used by methods like hashCode()) when computed, as the content never changes.
- This improves performance in scenarios where strings are used as keys in hash-based collections like HashMap or
  HashSet.
- If String were mutable, the hash code would need to be recalculated every time, negating this optimization.

**Predictable behavior**

- Immutability ensures that operations on a String (e.g., toUpperCase(), substring()) return a new String object rather
  than modifying the original. This avoids side effects and makes code easier to reason about and debug.

## How do you write custom Immutable class?

- The class should be **final**, preventing subclasses from overriding its behavior.
- The class members should be **private & final**, private to prevent external access, final to ensure they are assigned
  only once.
- The class method should be ** only getters**,Return defensive copies for mutable fields. No setters are allowed.
- The class should have constructor for first time initialization. Make defensive copies of mutable objects.

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public final class ImmutablePerson {
    private final String name;
    private final int age;
    private final List<String> hobbies; // Mutable object

    // Constructor for initialization
    public ImmutablePerson(String name, int age, List<String> hobbies) {
        this.name = name;
        this.age = age;
        // Defensive copy of mutable input
        this.hobbies = new ArrayList<>(hobbies);
    }

    // Getter for name
    public String getName() {
        return name;
    }

    // Getter for age
    public int getAge() {
        return age;
    }

    // Getter for hobbies (returns defensive copy)
    public List<String> getHobbies() {
        return Collections.unmodifiableList(new ArrayList<>(hobbies));
    }

    // No setters or methods that modify state
}
```

## 3. Explain Internal Working of HashMap?

- HashMap uses a hash table to store key-value pairs.
  **Array of Buckets**
- When we create an HashMap Object. JVM creates any array of size 16.
- Each bucket can store multiple entries (in case of hash collisions) using a linked list or balanced tree.
  **Hashing**
- When a key-value pair is added (put), the key’s hashCode() method is called to generate a hash code. sometimes,
  hashcode value is very big number, Technically it not possible to create such an big array.
- The hash code is mapped to a bucket index by using some modular function. This modular function brings down the
  value.

```aiignore
index = hash & (table.length - 1)
```

To reduce collisions, HashMap applies a supplemental hash function.

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

- This mixes the higher and lower bits of the hash code to improve distribution
  **Hash Collision**
- If the hashcode value is same for 2 keys then the bucket is turned to Linked List or Balanced Tree.
  **Java 8 Enhancement**
- If a bucket contains more than TREEIFY_THRESHOLD (8) entries, the linked list is converted to a red-black tree,
  improving worst-case performance from O(n) to O(log n).
- This is particularly effective when keys have poor hash functions or intentional hash collisions (e.g., in a
  denial-of-service attack).
- If the bucket size shrinks below UNTREEIFY_THRESHOLD (6), it reverts to a linked list to save memory.

# 4. When to Use String, StringBuffer, or StringBuilder in Java

- String : New Object is created on modification.
- String Builder : Mutable and Not Thread Safe (Performance is critical (Fast)). Can be modified without creating new
  objects. Ideal for single Threaded scenarios. Good choice for strings that require frequent modification in single
  threaded contexts.
- String Buffer : Mutable and Thread Safe (Performance is not critical). Similar to StringBuilder but synchronized.
  Slower but safe in multithreaded environments. Suitable for strings that require frequent modification in
  multithreaded contexts.

# 5. How to create a singleton custom class?

- The class members should be private static to hold single instance of class.
- The class constructor should be private to prevent external code from creating new instances using the new keyword.
- The class methods should be public static which returns current class object. (Typically a factory method)

```java
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {
        if (instance != null) {
            throw new IllegalAccessException("Create Singleton Object from getInstance() method");
        }
    }

    public static getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
    }
}
```

# 6. Why You Cannot Create an Instance of an Abstract Class?

- In Java, you cannot create an instance of an abstract class because it is designed to be incomplete and serve as a
  blueprint for subclasses.
- An abstract class is a class declared with the abstract keyword, which may contain abstract methods (methods without a
  body) or a mix of abstract and concrete (implemented) methods.
- Since abstract methods lack implementation, the class is considered incomplete. Instantiating such a class would leave
  undefined behavior for abstract methods.
- Abstract classes are meant to act as a template or base class for other classes to extend and provide implementations
  for abstract methods.
- The Java compiler explicitly prohibits creating instances of abstract classes to prevent runtime errors that would
  occur if an abstract method were called (since it has no implementation).
- Attempting to instantiate an abstract class results in a compile-time error.

```java
abstract class Animal {
    abstract void makeSound(); // Abstract method with no implementation

    void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Animal animal = new Animal(); // Compile-time error: Animal is abstract; cannot be instantiated
        Animal dog = new Dog(); // Valid: Dog is a concrete subclass
        dog.makeSound(); // Outputs: Woof!
        dog.eat(); // Outputs: Animal is eating
    }
}
```

- Animal is abstract and cannot be instantiated directly because it contains an abstract method (makeSound()).
- Dog, a concrete subclass, provides an implementation for makeSound(), making it instantiable.
- You can create an instance of Dog and refer to it using an Animal reference (polymorphism), but you cannot instantiate
  Animal itself.

# 7. Can abstract class have constructors?

- Yes, we can have constructors (default or explicit).
- Purpose: initialize common state that all concrete subclasses inherit.
- The constructor is never invoked directly with new; it is called implicitly via super() from the subclass constructor.
- Abstract class constructor runs first and Then the child class constructor runs.

```java
// Abstract base class
abstract class Vehicle {
    private final String vin;           // common state
    private final int year;

    // Constructor in an abstract class
    protected Vehicle(String vin, int year) {
        this.vin = vin;
        this.year = year;
        System.out.println("Vehicle(" + vin + ", " + year + ")");
    }

    public String getVin() {
        return vin;
    }

    public int getYear() {
        return year;
    }

    abstract void startEngine();        // to be provided by subclasses
}

// Concrete subclass
class Car extends Vehicle {
    private final String fuelType;

    public Car(String vin, int year, String fuelType) {
        super(vin, year);               // calls abstract-class constructor
        this.fuelType = fuelType;
        System.out.println("Car(" + fuelType + ")");
    }

    @Override
    void startEngine() {
        System.out.println("Starting " + fuelType + " engine of car " + getVin());
    }
}

// Demo
public class Demo {
    public static void main(String[] args) {
        Car c = new Car("1A2B3C", 2025, "Petrol");
        c.startEngine();
    }
}
```

Output:

```bash
Vehicle(1A2B3C, 2025)
Car(Petrol)
Starting Petrol engine of car 1A2B3C
```

# What is an interface?

- An interface is like a blueprint for a class.
- It defines set of methods that any class can implement.
- An interface says "What needs to be done", but not how it will be done.
- Interfaces can have abstract methods (no body) and Constants (public static final variables)
- In Java8, interfaces are upgraded to support default methods (with body) and static methods (with body).
- This allowed to add new methods to interfaces without breaking existing implementations and writing shared logic in
  interfaces.

## Why default methods introduced in interface as part of Java 8?

- Before Java 8, If we add new method in an interface, all implementing classes had to update or implement new method.
- After Java 8, If we add new method in an interface, existing classes will not break. (no need implement new method in
  existing class).

## Why static methods introduced in interface as part of Java 8?

- Static methods are called directly using interface name without requiring object creation and separate utility
  classes.
- Classes are heavy and interface is lightweight. Hence, it is better to go for interfaces in case of static methods.

## Why private methods are introduced in interface as part of Java 9 ?

- Before Java 9, interfaces can have default and static methods , If we have a common code logic which is used in
  multiple default methods then we need to write that logic in each default method. This led to duplicate code and poor
  design.
- After Java 9, To avoid code duplication issue interface are allowed to have private methods. Common code is written
  once and shared only with in the interface. The common code logic is not exposed to implementing classes which
  supports encapsulation.

- **Interfaces focus on *what*, abstract classes focus on *how***

# How 'this' keyword is differ from class vs anonymous class vs lambda Expression?

| Context               | Meaning of this                                       |
|-----------------------|-------------------------------------------------------|
| Normal class          | Current Object of the class                           |
| Anonymous Inner class | Instance of Anonymous Inner class                     |
| Lambda Expression     | Instance of enclosing class (Same as outside of class |

Note:

- Anonymous Inner class introduces a new scope and new this keyword.
- Lambda does not introduce a new this; it shares this with the enclosing context.

## What is the purpose of static keyword?

- The static keyword in Java is used to indicate that a member belongs to the class rather than any specific object.
- Static members can be accessed without creating an instance of the class.

```java
class Demo {
    static int count = 0;

    static void showCount() {
        System.out.println("Count is: " + count);
    }
}

public class Main {
    public static void main(String[] args) {
        Demo.count = 5;         // Accessing static variable without object
        Demo.showCount();       // Calling static method without object
    }
}
```

## What is the purpose of static block in java?

- A static block is used to initialize static variables.
- It executes only once, when class is loaded into memory (before any object is created or static method is called)

## What are different access modifiers in java and their significance?

- Access modifiers in java control accessibility of classes, methods and variables.
- *public* : accessible from any other class.
- *protected* : accessible with in same package or by subclasses (even in other packages).
- *default* : accessible only with the same package.
- *private* :accessible only with in the class where it is declared.

## How to create custom annotation in Java?

- Annotations are special tags (starting with @) that add metadata to your code.
- They tell the compiler or runtime something about the code, like instructions or info.
- You can create your own annotation using @interface

```java 
// Step 1: Create Custom Annotation
@interface TestInfo {
    String createdBy() default "User";

    String description();
}

// Step 2: Apply Annotation
@TestInfo(description = "This is a test class", createdBy = "Prakash")
public class Demo {
    public static void main(String[] args) {
        System.out.println("Running Demo...");
    }
}
```

# How to create Immutable Objects?
- 

## Why Immutable Objects are important in Java?

- Immutable objects are objects whose state (data) cannot be changed after they are created.
- Once you set their values in the constructor, you can only read them not modify.
- Immutable Objects are Thread safe, There are predictable and no side effects. They always behave the same way.
- They are safe for caching and sharing.
- they are used in functional programming and concurrent applications.

# What is the purpose of the "this" keyword?

- The 'this' keyword in Java refers to the current instance of the class.
- Differentiate between class fields and parameters with the same names.
- Pass the current object as a parameter to another method.
- Invoke current class methods.

# What is the use of clone method in Java?

- The clone() method is used to create a copy (duplicate) of an object in Java.
- It performs a field-by-field copy of the object.
- It is defined in the Object class and must be overridden for custom classes.
- The class must implement Cloneable interface to avoid CloneNotSupportedException.
- The clone() method should be overridden as public in your class.
- It returns a shallow copy by default (deep copy must be manually implemented).

# What is the difference between deep copy and shallow copy?

- *Shallow Copy* : A shallow copy of an object copies the values of the object’s properties. However, if the property
  values are references to other objects, the references are copied but not the objects they point to.
- *Deep Copy* : a deep copy copies all fields, and if the fields contain references to other objects, it copies those
  objects as well. A deep copy is fully independent of the original object.