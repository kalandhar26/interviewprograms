# Liskov Substitution Principle (LSP)

## Scenario

- We model Bank Accounts. The bank has: Savings Account, Current Account, Fixed Deposit (FD) Account
- **Key Fact:** Fixed Deposit accounts do NOT allow withdrawal anytime.

## Before LSP (Violation)

- The base class promises withdrawal, but not all child classes can fulfill it. (Wrong abstraction).

```java
public abstract class BankAccountBeforeLSP {

    protected double balance;

    public BankAccountBeforeLSP(double balance) {
        this.balance = balance;
    }

    public abstract void withdraw(double amount);

    public double getBalance() {
        return balance;
    }
}
```

- Savings Account

```java
public class SavingsAccount extends BankAccountBeforeLSP {

    public SavingsAccount(double balance) {
        super(balance);
    }

    @Override
    public void withdraw(double amount) {
        balance -= amount;
        System.out.println("Savings withdrawal of ₹" + amount);
    }
}
```

- Fixed Deposit Account (LSP Broken)

```java
public class FixedDepositAccount extends BankAccountBeforeLSP {

    public FixedDepositAccount(double balance) {
        super(balance);
    }

    @Override
    public void withdraw(double amount) {
        throw new UnsupportedOperationException(
                "Withdrawal not allowed from Fixed Deposit before maturity"
        );
    }
}
```

- Client Code (Breaks at Runtime)

```java
public class BankService {

    public void processWithdrawal(BankAccountBeforeLSP account, double amount) {
        account.withdraw(amount);
    }

    public static void main(String[] args) {

        BankService service = new BankService();

        BankAccountBeforeLSP savings = new SavingsAccount(5000);
        service.processWithdrawal(savings, 1000); // ✅ Works

        BankAccountBeforeLSP fd = new FixedDepositAccount(10000);
        service.processWithdrawal(fd, 2000); // ❌ Runtime exception
    }
}
```

### Why This Violates LSP

- Parent class promised withdrawal
- Child class (FD) cannot fulfill it
- Substitution breaks at runtime
- Causes production failures in banking apps
- If it throws an exception when substituted, it breaks LSP

## After LSP ((Correct Design))

- **FIX** : Separate What varies using Interfaces

### Step 1 : Base Account (Common Behavior Only)

```java
public abstract class BankAccount {

    protected double balance;

    public BankAccount(double balance) {
        this.balance = balance;
    }

    public double getBalance() {
        return balance;
    }
}
```

- No false promises

### Step 2 : Withdrawable interface.

```java
public interface Withdrawable {
    void withdraw(double amount);
}
```

### Step 3 : Deposit Interface

```java
public interface Depositable {
    void deposit(double amount);
}
```

### Step 4 : Savings Account (Withdraw + Deposit)

```java
public class SavingsAccount extends BankAccount
        implements Withdrawable, Depositable {

    public SavingsAccount(double balance) {
        super(balance);
    }

    @Override
    public void withdraw(double amount) {
        balance -= amount;
        System.out.println("Savings withdrawal of ₹" + amount);
    }

    @Override
    public void deposit(double amount) {
        balance += amount;
    }
}
```

### Step 5 : Fixed Deposit Account (Only Deposit)

```java
public class FixedDepositAccount extends BankAccount
        implements Depositable {

    public FixedDepositAccount(double balance) {
        super(balance);
    }

    @Override
    public void deposit(double amount) {
        System.out.println("FD deposit of ₹" + amount);
        balance += amount;
    }
}
```

### Step 6 : Client Code (LSP Safe)

```java
public class BankService {

    public void processDeposit(Depositable account, double amount) {
        account.deposit(amount);
    }

    public void processWithdrawal(Withdrawable account, double amount) {
        account.withdraw(amount);
    }

    public static void main(String[] args) {

        BankService service = new BankService();

        SavingsAccount savings = new SavingsAccount(5000);
        service.processWithdrawal(savings, 1000); // ✅ Allowed

        FixedDepositAccount fd = new FixedDepositAccount(10000);
        service.processDeposit(fd, 2000); // ✅ Allowed

        // service.processWithdrawal(fd, 1000); ❌ Compile-time error (correct)
    }
}
```

## Real-World Banking Benefits

✔ Prevents runtime failures
✔ Business rules enforced at design time
✔ Safer transaction processing
✔ Easier compliance & audits
✔ Clean domain modeling