## S – Single Responsibility Principle (SRP)

- A class should have only one reason to change.
- A class should have only one job or responsibility. If a class is handling multiple things (e.g., business logic and
  database operations), changes in one concern may affect the other.
- Promotes modularity.
- Makes code easier to understand, test, and maintain.

### Coding Example

- **One class handles:**
- Account data
- Database operations
- Transaction Report generation

```java
public class BankAccountBeforeSRP {

    private String accountNumber;
    private double balance;

    public BankAccountBeforeSRP(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }

    public void deposit(double amount) {
        balance += amount;
        System.out.println("Amount deposited: " + amount);
    }

    public void saveAccount() {
        // Database logic
        System.out.println("Account saved to database");
    }

    public void generateTransactionReceipt(double amount) {
        // Report generation logic
        System.out.println("Report: Account " + accountNumber +
                " credited with ₹" + amount +
                ", Current Balance: ₹" + balance);
    }
}

```

- **Problems with this design**
- Multiple responsibilities
- Tight coupling (business logic + DB + reporting)
- Hard to test
- High impact of change
- **Reasons to change:**
- Change in DB → modify class
- Change in receipt format → modify class
- Change in business logic → modify class

➡️ **One class, many reasons to change = SRP violation**

### Solution (CORRECT DESIGN)

- We split responsibilities into focused classes.

#### **Account Entity (Only Business State)**

```java
public class BankAccount {

    private String accountNumber;
    private double balance;

    public BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }

    public void deposit(double amount) {
        balance += amount;
    }

    public String getAccountNumber() {
        return accountNumber;
    }

    public double getBalance() {
        return balance;
    }
}
```

- represents account data and maintains business data.

#### Repository Layer (DB Responsibility Only)

```java
public class BankAccountRepository {

    public void save(BankAccount account) {
        // Database persistence logic
        System.out.println("Bank account saved to database");
    }
}
```

- Handles database operations
- Changes only when DB logic changes

#### Receipt / Statement Generator (Reporting Responsibility Only)

```java
public class TransactionReportGenerator {

    public void generateReport(BankAccount account, double amount) {
        System.out.println(
                "Receipt: Account " + account.getAccountNumber() +
                        " credited with ₹" + amount +
                        ", Current Balance: ₹" + account.getBalance()
        );
    }
}
```

- Generates transaction receipts and Changes only when receipt format changes

#### Test / Client Code

```java
public class BankApplication {

    public static void main(String[] args) {

        BankAccount account = new BankAccount("ACC123", 1000.0);

        account.deposit(500.0);

        BankAccountRepository repository = new BankAccountRepository();
        repository.save(account);

        TransactionReceiptGenerator receiptGenerator =
                new TransactionReceiptGenerator();
        receiptGenerator.generateReceipt(account, 500.0);
    }
}

```

## Benefits in Banking Systems

✔ Loose coupling
✔ Easier unit testing
✔ Regulatory changes don’t break core logic
✔ Clear separation of concerns
✔ Scales well in microservices architecture